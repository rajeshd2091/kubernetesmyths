"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1155],{7483:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service","title":"Myth: \'kubectl port-forward svc\' sends traffic to a service","description":"Many engineers assume that running:","source":"@site/docs/k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service.md","sourceDirName":"k8s-core-myths/networking-myths","slug":"/k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service","permalink":"/k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"k8sCoreMythsSidebar","previous":{"title":"Myth: ClusterIP Service Always Use Round-Robin Load Balancing","permalink":"/k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing"},"next":{"title":"Myth: NodePort Service Always Exposes the Application to the Internet","permalink":"/k8s-core-myths/networking-myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet"}}');var s=t(4848),i=t(8453);const o={sidebar_position:5},c="Myth: 'kubectl port-forward svc' sends traffic to a service",a={},l=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3}];function d(e){const r={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"myth-kubectl-port-forward-svc-sends-traffic-to-a-service",children:"Myth: 'kubectl port-forward svc' sends traffic to a service"})}),"\n",(0,s.jsx)(r.p,{children:"Many engineers assume that running:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"kubectl port-forward svc/my-service 8080:80\n"})}),"\n",(0,s.jsx)(r.p,{children:"routes traffic through the Service to its backend Pods\u2014just like a real client request would. But if you analyze the traffic flow, you'll notice something surprising\u2014the Service is completely bypassed!"}),"\n",(0,s.jsx)(r.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["The command uses ",(0,s.jsx)(r.code,{children:"svc/my-service"}),", which makes it seem like traffic will flow through the Service."]}),"\n",(0,s.jsxs)(r.li,{children:["Since Services load balance traffic, it's natural to assume ",(0,s.jsx)(r.code,{children:"port-forward"})," does the same."]}),"\n",(0,s.jsx)(r.li,{children:"The actual forwarding logic is not well-documented, leading to confusion."}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,s.jsxs)(r.p,{children:["Even if you specify a Service in the ",(0,s.jsx)(r.code,{children:"kubectl port-forward"})," command, the traffic never reaches the Service. Instead, ",(0,s.jsx)(r.strong,{children:"Kubernetes picks a single Pod behind the Service and forwards traffic directly to that Pod\u2014bypassing the Service entirely."})]}),"\n",(0,s.jsx)(r.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,s.jsx)(r.p,{children:"Step 1: Create a Service with Multiple Pods\r\nApply the following YAML:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"apiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  name: productpage\r\nspec:\r\n  selector:\r\n    app: productpage\r\n  ports:\r\n    - protocol: TCP\r\n      port: 80\r\n      targetPort: 8080\r\n\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"apiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: productpage\r\nspec:\r\n  replicas: 3\r\n  selector:\r\n    matchLabels:\r\n      app: productpage\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: productpage\r\n    spec:\r\n      containers:\r\n        - name: app\r\n          image: nginx\r\n          ports:\r\n            - containerPort: 8080\r\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"Step 2: Run kubectl port-forward and Check Traffic Flow\r\nForward traffic using:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"kubectl port-forward svc/productpage 8080:80\n"})}),"\n",(0,s.jsx)(r.p,{children:"Then check which Pod is actually receiving traffic:\r\n#TODO - Include Kiali image"}),"\n",(0,s.jsx)(r.p,{children:"You'll notice no traffic hits the Service itself, confirming that requests go directly to a Pod."}),"\n",(0,s.jsx)(r.p,{children:"###Key Takeaways"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"kubectl port-forward"})," ",(0,s.jsx)(r.strong,{children:"does not send traffic through the Service"}),"\u2014it picks one Pod and forwards directly."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"No load balancing:"})," Traffic is not distributed among multiple Pods."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"No failover:"})," If the chosen Pod crashes, the connection is lost."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Not a true service test:"})," If you want to simulate real client traffic, use Ingress, LoadBalancer, or NodePort."]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>o,x:()=>c});var n=t(6540);const s={},i=n.createContext(s);function o(e){const r=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);