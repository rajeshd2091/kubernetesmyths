"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[567],{5226:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"architectureSidebar":[{"type":"link","href":"/architecture-myths/overview","label":"Overview","docId":"architecture-myths/overview","unlisted":false},{"type":"link","href":"/architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes","label":"Myth: Kubelet is Exclusive to Worker Nodes","docId":"architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes","unlisted":false},{"type":"link","href":"/architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy","label":"Myth: Kubernetes Clusters Can\'t Function Without Kube-Proxy","docId":"architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy","unlisted":false},{"type":"link","href":"/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin","label":"Myth: Kubernetes Networking Works Fine Without a CNI Plugin","docId":"architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin","unlisted":false},{"type":"link","href":"/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","label":"Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime","docId":"architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","unlisted":false}],"workloadSidebar":[{"type":"link","href":"/workload_myths/overview","label":"Overview","docId":"workload_myths/overview","unlisted":false},{"type":"link","href":"/workload_myths/Complete_application_can_be_rolled_back_in_Kubernetes","label":"Myth: Complete application can be rolled back in Kubernetes","docId":"workload_myths/Complete_application_can_be_rolled_back_in_Kubernetes","unlisted":false},{"type":"link","href":"/workload_myths/Rolling_Updates_Are_Only_Supported_by_Deployments","label":"Myth: Rolling Updates Are Only Supported by Deployments","docId":"workload_myths/Rolling_Updates_Are_Only_Supported_by_Deployments","unlisted":false},{"type":"link","href":"/workload_myths/DaemonSet_always_schedule_pods_on_all_nodes","label":"Myth: DaemonSet always schedule pods on all nodes.","docId":"workload_myths/DaemonSet_always_schedule_pods_on_all_nodes","unlisted":false},{"type":"link","href":"/workload_myths/Deployment_Supports_All_Pod_Restart_Policies","label":"Myth: Deployment Supports All Pod Restart Policies","docId":"workload_myths/Deployment_Supports_All_Pod_Restart_Policies","unlisted":false},{"type":"link","href":"/workload_myths/Kubernetes_automatically_roll_back_failed_deployment","label":"Myth: Kubernetes Automatically Roll Back Failed Deployment","docId":"workload_myths/Kubernetes_automatically_roll_back_failed_deployment","unlisted":false},{"type":"link","href":"/workload_myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var","label":"Myth: Kubernetes always injects information about Services into a Pod","docId":"workload_myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var","unlisted":false}],"networkingSidebar":[{"type":"link","href":"/networking_myths/overview","label":"Overview","docId":"networking_myths/overview","unlisted":false},{"type":"link","href":"/networking_myths/kube_proxy_assign_IP_address_to_Pods","label":"Myth: kube-proxy assign IP address to Pods","docId":"networking_myths/kube_proxy_assign_IP_address_to_Pods","unlisted":false},{"type":"link","href":"/networking_myths/ClusterIP_Service_is_Only_for_Internal_Traffic","label":"Myth: ClusterIP Service is Only for Internal Traffic","docId":"networking_myths/ClusterIP_Service_is_Only_for_Internal_Traffic","unlisted":false},{"type":"link","href":"/networking_myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","label":"Myth: ClusterIP Service Always Use Round-Robin Load Balancing","docId":"networking_myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","unlisted":false},{"type":"link","href":"/networking_myths/kubectl_port-forward_svc_sends_traffic_to_a_service","label":"Myth: \'kubectl port-forward svc\' sends traffic to a service","docId":"networking_myths/kubectl_port-forward_svc_sends_traffic_to_a_service","unlisted":false},{"type":"link","href":"/networking_myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet","label":"Myth: NodePort Service Always Exposes the Application to the Internet","docId":"networking_myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet","unlisted":false}],"storageSidebar":[{"type":"link","href":"/storage_myths/overview","label":"Overview","docId":"storage_myths/overview","unlisted":false},{"type":"link","href":"/storage_myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass","label":"Myth: Kubernetes Cluster Can Have Only One Default StorageClass","docId":"storage_myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass","unlisted":false},{"type":"link","href":"/storage_myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized","label":"Myth: Kubernetes PersistentVolumeClaim Can Be Resized","docId":"storage_myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized","unlisted":false},{"type":"link","href":"/storage_myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","label":"Myth: ReadWriteOnce mode allows only a single Pod to access the volume","docId":"storage_myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","unlisted":false}],"securitySidebar":[{"type":"link","href":"/security_myths/overview","label":"Overview","docId":"security_myths/overview","unlisted":false},{"type":"link","href":"/security_myths/Kubernetes_Namespaces_Provide_Complete_Isolation","label":"Myth: Kubernetes Namespaces Provide Complete Isolation","docId":"security_myths/Kubernetes_Namespaces_Provide_Complete_Isolation","unlisted":false},{"type":"link","href":"/security_myths/Kubernetes_Service_Accounts_Pull_Container_Images","label":"Myth: Kubernetes Service Accounts Pull Container Images","docId":"security_myths/Kubernetes_Service_Accounts_Pull_Container_Images","unlisted":false}]},"docs":{"architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime":{"id":"architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","title":"Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime","description":"You set up your control plane node, confident that everything is configured correctly. Next, you run kubeadm init, expecting a smooth setup\u2014but it fails instantly!","sidebar":"architectureSidebar"},"architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes":{"id":"architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes","title":"Myth: Kubelet is Exclusive to Worker Nodes","description":"You SSH into a control plane node, expecting to see only control plane components like the API server, controller manager, and scheduler running. But wait\u2014why is Kubelet there? Wasn\'t it supposed to run only on worker nodes?","sidebar":"architectureSidebar"},"architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy":{"id":"architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy","title":"Myth: Kubernetes Clusters Can\'t Function Without Kube-Proxy","description":"You deploy a Kubernetes cluster and start checking the usual system components. API server? Running. Controller manager? Running. Kube-Proxy? Wait\u2026 it\'s missing! You double-check the namespace, logs, and even the deployment\u2014nothing. But surprisingly, your pods and services are still communicating just fine. How is this possible? Isn\'t Kube-Proxy essential for cluster networking?","sidebar":"architectureSidebar"},"architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin":{"id":"architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin","title":"Myth: Kubernetes Networking Works Fine Without a CNI Plugin","description":"You set up a Production Kubernetes cluster, deploy some pods, and\u2026 nothing. They can\'t talk to each other, You search Stack Overflow, try restarting pods, but nothing works, Finally, you realize networking is broken, and some pods are stuck in \\"ContainerCreating\\" state. You check the logs and see:","sidebar":"architectureSidebar"},"architecture-myths/overview":{"id":"architecture-myths/overview","title":"Overview","description":"Kubernetes architecture is often perceived as a black box\u2014with terms like \\"control plane,\\" \\"kubelet,\\" and \\"scheduler\\" thrown around without deep clarity. This section tackles myths rooted in these components, where surface-level understanding leads to poor design choices and debugging frustrations.","sidebar":"architectureSidebar"},"intro":{"id":"intro","title":"Tutorial Intro","description":"Let\'s discover Docusaurus in less than 5 minutes."},"networking_myths/ClusterIP_Service_is_Only_for_Internal_Traffic":{"id":"networking_myths/ClusterIP_Service_is_Only_for_Internal_Traffic","title":"Myth: ClusterIP Service is Only for Internal Traffic","description":"You\u2019ve just configured a ClusterIP service to expose one of your pods internally in your Kubernetes cluster. It seems like a straightforward setup\u2014after all, ClusterIP services are meant to route traffic between pods within the cluster, right? So, you assume that it\u2019s all about internal communication.","sidebar":"networkingSidebar"},"networking_myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing":{"id":"networking_myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","title":"Myth: ClusterIP Service Always Use Round-Robin Load Balancing","description":"Have you ever assumed that your pods are getting equal traffic? Many engineers believe Kubernetes distributes traffic evenly across pods in a strict round-robin manner. But if you actually monitor request distribution, you\u2019ll notice something surprising\u2014some pods receive more traffic than others. Is Kubernetes failing at load balancing? Not really. It turns out that the default behavior isn\'t what most people expect.","sidebar":"networkingSidebar"},"networking_myths/kube_proxy_assign_IP_address_to_Pods":{"id":"networking_myths/kube_proxy_assign_IP_address_to_Pods","title":"Myth: kube-proxy assign IP address to Pods","description":"A common belief among Kubernetes users is that kube-proxy is responsible for assigning IP addresses to pods. After all, it manages networking rules and enables communication between services\u2014so it must be the component handling pod IPs, right?","sidebar":"networkingSidebar"},"networking_myths/kubectl_port-forward_svc_sends_traffic_to_a_service":{"id":"networking_myths/kubectl_port-forward_svc_sends_traffic_to_a_service","title":"Myth: \'kubectl port-forward svc\' sends traffic to a service","description":"Many engineers assume that running:","sidebar":"networkingSidebar"},"networking_myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet":{"id":"networking_myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet","title":"Myth: NodePort Service Always Exposes the Application to the Internet","description":"During a production debugging call, a team raised an urgent security concern:","sidebar":"networkingSidebar"},"networking_myths/overview":{"id":"networking_myths/overview","title":"Overview","description":"Networking in Kubernetes often feels like magic\u2014until it breaks.","sidebar":"networkingSidebar"},"security_myths/Kubernetes_Namespaces_Provide_Complete_Isolation":{"id":"security_myths/Kubernetes_Namespaces_Provide_Complete_Isolation","title":"Myth: Kubernetes Namespaces Provide Complete Isolation","description":"Many teams assume that creating separate namespaces guarantees strong isolation between workloads, preventing them from affecting each other. But this belief can lead to critical security oversights.","sidebar":"securitySidebar"},"security_myths/Kubernetes_Service_Accounts_Pull_Container_Images":{"id":"security_myths/Kubernetes_Service_Accounts_Pull_Container_Images","title":"Myth: Kubernetes Service Accounts Pull Container Images","description":"During internal security audits and team discussions, several engineers assumed that ServiceAccounts were used to authenticate with container registries. One developer even tried granting additional RBAC permissions to a ServiceAccount in an attempt to fix an image-pull failure from a private registry. The issue persisted, and only later did the team realize that the ServiceAccount had no role in image retrieval at all. The failure was caused by missing imagePullSecrets, not ServiceAccount permissions.","sidebar":"securitySidebar"},"security_myths/overview":{"id":"security_myths/overview","title":"Overview","description":"Kubernetes security is often misunderstood, not because the platform is insecure, but because its design principles differ from traditional infrastructure and application security models. Many teams assume Kubernetes automatically provides strong isolation, network safety, secure defaults, or hardened workloads. In reality, Kubernetes only offers building blocks\u2014misinterpreting these building blocks leads to configuration gaps, risky deployments, and a false sense of security.","sidebar":"securitySidebar"},"storage_myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass":{"id":"storage_myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass","title":"Myth: Kubernetes Cluster Can Have Only One Default StorageClass","description":"You\'re defining a new StorageClass and set:","sidebar":"storageSidebar"},"storage_myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized":{"id":"storage_myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized","title":"Myth: Kubernetes PersistentVolumeClaim Can Be Resized","description":"During a design discussion, a team member confidently stated that \u201cPVCs in Kubernetes are fully resizable \u2014 you can increase or decrease storage whenever you want.\u201d This assumption influenced their storage planning and automated cleanup strategy.","sidebar":"storageSidebar"},"storage_myths/overview":{"id":"storage_myths/overview","title":"Overview","description":"In Kubernetes, compute may steal the spotlight \u2014 but persistent storage is what truly powers workloads.","sidebar":"storageSidebar"},"storage_myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume":{"id":"storage_myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","title":"Myth: ReadWriteOnce mode allows only a single Pod to access the volume","description":"During one of my interviews, the panel asked me, \u201cWhy does Kubernetes restrict RWO volumes to a single Pod?\u201d","sidebar":"storageSidebar"},"workload_myths/Complete_application_can_be_rolled_back_in_Kubernetes":{"id":"workload_myths/Complete_application_can_be_rolled_back_in_Kubernetes","title":"Myth: Complete application can be rolled back in Kubernetes","description":"A team deployed a new version of their microservices-based application in Kubernetes. Soon after, they noticed critical issues and decided to roll back using:","sidebar":"workloadSidebar"},"workload_myths/DaemonSet_always_schedule_pods_on_all_nodes":{"id":"workload_myths/DaemonSet_always_schedule_pods_on_all_nodes","title":"Myth: DaemonSet always schedule pods on all nodes.","description":"Expect DaemonSet to Run on Every Node? Not So Fast! Many assume that a DaemonSet automatically schedules a Pod on every node in the cluster. While this is generally true, there are several cases where DaemonSet does not schedule Pods on all nodes.","sidebar":"workloadSidebar"},"workload_myths/Deployment_Supports_All_Pod_Restart_Policies":{"id":"workload_myths/Deployment_Supports_All_Pod_Restart_Policies","title":"Myth: Deployment Supports All Pod Restart Policies","description":"Can You Use Any Restart Policy in a Deployment?","sidebar":"workloadSidebar"},"workload_myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var":{"id":"workload_myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var","title":"Myth: Kubernetes always injects information about Services into a Pod","description":"I was attending a free Kubernetes webinar where the speaker was walking through service discovery patterns.","sidebar":"workloadSidebar"},"workload_myths/Kubernetes_automatically_roll_back_failed_deployment":{"id":"workload_myths/Kubernetes_automatically_roll_back_failed_deployment","title":"Myth: Kubernetes Automatically Roll Back Failed Deployment","description":"A team deployed a new version of their application, expecting Kubernetes to roll it back automatically if something went wrong. Unfortunately, the deployment failed, but instead of rolling back, Kubernetes left it in a bad state. The team was surprised\u2014wasn\'t Kubernetes supposed to handle this automatically?","sidebar":"workloadSidebar"},"workload_myths/overview":{"id":"workload_myths/overview","title":"Overview","description":"Deploying workloads in Kubernetes may seem straightforward\u2014but lurking underneath are subtle behaviors that often surprise even experienced engineers.","sidebar":"workloadSidebar"},"workload_myths/Rolling_Updates_Are_Only_Supported_by_Deployments":{"id":"workload_myths/Rolling_Updates_Are_Only_Supported_by_Deployments","title":"Myth: Rolling Updates Are Only Supported by Deployments","description":"Many believe that rolling updates are an exclusive feature of Kubernetes Deployments. This assumption leads to the misconception that StatefulSets and DaemonSets do not support rolling updates, forcing teams to use workarounds. But is this really the case?","sidebar":"workloadSidebar"}}}}')}}]);