"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[4507],{1661:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build once_deploy_anywhere","title":"Myth: Container images truly support \u201cbuild once, deploy anywhere\\"","description":"This statement is frequently repeated in container and DevOps communities. Many engineers confidently claim that once a container image is built, it can run on any machine or Kubernetes cluster, regardless of the underlying hardware.During discussions with developers and SREs, this belief appears almost universally accepted.","source":"@site/docs/k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build once_deploy_anywhere.md","sourceDirName":"k8s-ecosystem-myths/container-image-myths","slug":"/k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build once_deploy_anywhere","permalink":"/k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build once_deploy_anywhere","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build once_deploy_anywhere.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"k8sEcosystemMythsSidebar","previous":{"title":"Container Image Myths","permalink":"/category/container-image-myths"},"next":{"title":"Myth: A Container Image Digest Uniquely Identifies One Image","permalink":"/k8s-ecosystem-myths/container-image-myths/A_Container_Image_Digest_Uniquely_Identifies_One_Image"}}');var t=i(4848),r=i(8453);const a={sidebar_position:2},l='Myth: Container images truly support \u201cbuild once, deploy anywhere"',c={},o=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function h(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"myth-container-images-truly-support-build-once-deploy-anywhere",children:'Myth: Container images truly support \u201cbuild once, deploy anywhere"'})}),"\n",(0,t.jsx)(n.p,{children:"This statement is frequently repeated in container and DevOps communities. Many engineers confidently claim that once a container image is built, it can run on any machine or Kubernetes cluster, regardless of the underlying hardware.During discussions with developers and SREs, this belief appears almost universally accepted."}),"\n",(0,t.jsx)(n.p,{children:"I once encountered a situation where an ARM-based edge device cluster was unable to run a standard amd64 image, leading to confusion because the team believed containers were inherently portable."}),"\n",(0,t.jsx)(n.p,{children:"The failure puzzled them because they assumed the \u201cbuild once, deploy anywhere\u201d promise applied universally."}),"\n",(0,t.jsx)(n.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,t.jsx)(n.p,{children:"There are several reasons that keeps this misconception alive:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Early Docker marketing heavily pushed the narrative that containers work like Java\u2019s \u201cwrite once, run anywhere.\u201d"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Registries automatically return the correct architecture-specific image variant, hiding the underlying complexity."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Most users work on clusters with a single architecture, so they never notice the limitations."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The difference between a single image and a multi-architecture manifest list is not widely understood."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Tooling has improved so much (QEMU, Buildx, manifest lists) that people assume portability is native, not orchestrated."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,t.jsx)(n.p,{children:"Container images are not inherently portable across architectures or operating systems."}),"\n",(0,t.jsx)(n.p,{children:"A standard container image is tightly coupled to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"CPU architecture (amd64, arm64, ppc64le, s390x\u2026)"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"OS and libc differences (glibc vs musl)"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"ABI compatibility"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"\u201cDeploy anywhere\u201d is only possible when you create a multi-architecture image that bundles multiple architecture-specific images under a single manifest list. The registry then serves the correct image variant based on the client platform."}),"\n",(0,t.jsx)(n.p,{children:"So the truth is:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"You don\u2019t build once."}),"\r\n",(0,t.jsx)(n.strong,{children:"You build multiple images (one per architecture) and package them as one reference."})]}),"\n",(0,t.jsx)(n.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,t.jsx)(n.p,{children:"You can verify this using Docker or any OCI-compliant client."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Step 1: Get your host machine architecture"})}),"\n",(0,t.jsx)(n.p,{children:"Use both OS-level and Docker-level checks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"uname -m\r\ndocker info --format '{{.Architecture}}'\r\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"Example Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"x86_64\r\nx86_64\n"})}),"\n",(0,t.jsxs)(n.p,{children:["So, ",(0,t.jsx)(n.code,{children:"x86_64"})," means host is using ",(0,t.jsx)(n.code,{children:"amd64"})]}),"\n",(0,t.jsx)(n.p,{children:"This tells you what architecture your containers are expected to run on natively."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Step 2: Pull an image for a different architecture"})}),"\n",(0,t.jsxs)(n.p,{children:["Let\u2019s say your host is ",(0,t.jsx)(n.code,{children:"amd64"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Then pull ",(0,t.jsx)(n.code,{children:"arm64"})," BusyBox:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"docker pull --platform linux/arm64/v8 busybox:latest\r\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Or vice-versa if your host is ",(0,t.jsx)(n.code,{children:"arm64"}),", then pull ",(0,t.jsx)(n.code,{children:"amd64"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"docker pull --platform linux/amd64 busybox:latest\r\n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Step 3: Try to run it"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"docker run --rm busybox:latest\r\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will fail with a classic platform-mismatch error."}),"\n",(0,t.jsx)(n.p,{children:"Typical Failure Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"WARNING: The requested image's platform (linux/arm64/v8) does not match the detected host platform (linux/amd64/v3) and no specific platform was requested\r\nexec /bin/echo: exec format error\n"})}),"\n",(0,t.jsx)(n.p,{children:"This experiment validates that container images are architecture-specific, and they cannot be deployed universally across heterogeneous environments"}),"\n",(0,t.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Container images are architecture-specific."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Images built for one architecture cannot run on a different architecture."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"True portability requires multi-architecture images (manifest lists)."}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);