"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[8657],{1527:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images","title":"Myth: Kubernetes Service Accounts Pull Container Images","description":"During internal security audits and team discussions, several engineers assumed that ServiceAccounts were used to authenticate with container registries. One developer even tried granting additional RBAC permissions to a ServiceAccount in an attempt to fix an image-pull failure from a private registry. The issue persisted, and only later did the team realize that the ServiceAccount had no role in image retrieval at all. The failure was caused by missing imagePullSecrets, not ServiceAccount permissions.","source":"@site/docs/k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images.md","sourceDirName":"k8s-core-myths/security-myths","slug":"/k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images","permalink":"/k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"k8sCoreMythsSidebar","previous":{"title":"Myth: Kubernetes Namespaces Provide Complete Isolation","permalink":"/k8s-core-myths/security-myths/Kubernetes_Namespaces_Provide_Complete_Isolation"}}');var s=t(4848),r=t(8453);const a={sidebar_position:3},c="Myth: Kubernetes Service Accounts Pull Container Images",o={},l=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality:",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function h(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"myth-kubernetes-service-accounts-pull-container-images",children:"Myth: Kubernetes Service Accounts Pull Container Images"})}),"\n",(0,s.jsx)(n.p,{children:"During internal security audits and team discussions, several engineers assumed that ServiceAccounts were used to authenticate with container registries. One developer even tried granting additional RBAC permissions to a ServiceAccount in an attempt to fix an image-pull failure from a private registry. The issue persisted, and only later did the team realize that the ServiceAccount had no role in image retrieval at all. The failure was caused by missing imagePullSecrets, not ServiceAccount permissions."}),"\n",(0,s.jsx)(n.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,s.jsx)(n.p,{children:"This misconception commonly arises because of two overlapping facts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ServiceAccounts can be linked to imagePullSecrets."})," When engineers attach registry credentials to a ServiceAccount, it creates an impression that the ServiceAccount is the entity responsible for authenticating and pulling images."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ServiceAccount tokens are automatically mounted into Pods."})," Since these tokens provide authentication to the Kubernetes API server, developers assume they might also be used for authenticating with container registries."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Both features involve authentication, but they serve different purposes, leading to widespread confusion."}),"\n",(0,s.jsx)(n.h3,{id:"the-reality",children:"The Reality:"}),"\n",(0,s.jsx)(n.p,{children:"A Kubernetes ServiceAccount has absolutely no role in pulling container images."}),"\n",(0,s.jsx)(n.p,{children:"Image pulling is performed entirely by the container runtime (containerd, CRI-O, or Docker) running on the worker node."}),"\n",(0,s.jsx)(n.p,{children:"Here is the actual sequence:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"A Pod is scheduled onto a node."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Kubelet verifies whether the required image exists locally."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the image is missing, Kubelet instructs the container runtime to pull it using the Container Runtime Interface (CRI)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The container runtime performs registry authentication using the credentials provided in imagePullSecrets."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Once authenticated, the runtime downloads, stores, and unpacks the image before starting the container."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The ServiceAccount is not consulted at any point in this workflow. It is solely used for Pod-to-API-server authentication."}),"\n",(0,s.jsx)(n.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Step 1. Create a Pod using a private image without imagePullSecrets"})}),"\n",(0,s.jsx)(n.p,{children:"Use a private image and do not specify any imagePullSecrets:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: test-no-creds\r\nspec:\r\n  containers:\r\n    - name: app\r\n      image: my-private-registry.com/app:v1\n"})}),"\n",(0,s.jsx)(n.p,{children:"Observe the Pod state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"kubectl describe pod test-no-creds\n"})}),"\n",(0,s.jsx)(n.p,{children:"You will see events such as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'Failed to pull image "my-private-registry.com/app:v1": authentication required\r\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"Notice that RBAC permissions on the ServiceAccount do not affect this result."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Setp 2. Attach imagePullSecrets directly to the Pod"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: test-with-creds\r\nspec:\r\n  containers:\r\n    - name: app\r\n      image: my-private-registry.com/app:v1\r\n  imagePullSecrets:\r\n    - name: my-registry-secret\r\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"The Pod will now successfully pull the image and start, proving that registry authentication depends on imagePullSecrets, not ServiceAccount permissions."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Setp 3. Attach imagePullSecrets to a ServiceAccount"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\r\nkind: ServiceAccount\r\nmetadata:\r\n  name: my-sa\r\nimagePullSecrets:\r\n  - name: my-registry-secret\r\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"and then:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: test-using-sa\r\nspec:\r\n  serviceAccountName: my-sa\r\n  containers:\r\n    - name: app\r\n      image: my-private-registry.com/app:v1\n"})}),"\n",(0,s.jsx)(n.p,{children:"The Pod succeeds\u2014but the authentication still happens exclusively through the imagePullSecret, not through the ServiceAccount token."}),"\n",(0,s.jsx)(n.p,{children:"The ServiceAccount merely references the secret; it never interacts with the container registry."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"ServiceAccounts do not pull container images."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The container runtime on the node is solely responsible for pulling images."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Kubelet only instructs the runtime; it does not authenticate with registries."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Private images require imagePullSecrets, not ServiceAccount permissions."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"ServiceAccounts authenticate Pods to the Kubernetes API server, not to container registries."}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);