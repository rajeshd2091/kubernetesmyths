"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[409],{8312:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","title":"Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime","description":"You set up your control plane node, confident that everything is configured correctly. Next, you run kubeadm init, expecting a smooth setup\u2014but it fails instantly!","source":"@site/docs/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime.md","sourceDirName":"architecture-myths","slug":"/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","permalink":"/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"architectureSidebar","previous":{"title":"Myth: Kubernetes Networking Works Fine Without a CNI Plugin","permalink":"/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin"}}');var i=t(4848),s=t(8453);const o={sidebar_position:5},l="Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime",a={},c=[{value:"Why Does This Myth Exist?",id:"why-does-this-myth-exist",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function d(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"myth--control-plane-nodes-dont-need-a-container-runtime",children:"Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime"})}),"\n",(0,i.jsxs)(n.p,{children:["You set up your control plane node, confident that everything is configured correctly. Next, you run ",(0,i.jsx)(n.code,{children:"kubeadm init"}),", expecting a smooth setup\u2014but it fails instantly!"]}),"\n",(0,i.jsxs)(n.p,{children:["The error? ",(0,i.jsx)(n.code,{children:"no container runtime detected."})]}),"\n",(0,i.jsx)(n.p,{children:"That\u2019s strange. Isn\u2019t the container runtime needed only on worker nodes to run application workloads? You double-check your configuration, thinking you might have missed a step. But the error persists."}),"\n",(0,i.jsx)(n.p,{children:"What\u2019s going on here? Why is Kubernetes complaining about a missing CRI on the control plane?"}),"\n",(0,i.jsx)(n.h3,{id:"why-does-this-myth-exist",children:"Why Does This Myth Exist?"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Over-Simplified Architecture Explanations"})," \u2013 Many Kubernetes learning resources describe the architecture in a rigid way: Control plane runs API Server, etcd, Scheduler, and Controller Manager, while worker nodes run Kubelet, CRI, and Kube-Proxy. This oversimplification leads to misconceptions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Misinterpretation of Control Plane Responsibilities"}),' \u2013 Since control plane components are often seen as "management-only," people assume they don\u2019t rely on container runtimes, networking components, or Kubelet.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Managed Kubernetes Abstraction"})," \u2013 Many managed Kubernetes services abstract away the control plane, making engineers believe that only worker nodes require components like CRI, Kubelet, or CNI."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Historical Understanding of Kubernetes"}),' \u2013 Earlier Kubernetes documentation and tutorials emphasized worker nodes as the place where "real workloads" run, reinforcing the belief that key infrastructure components don\u2019t function similarly on control plane nodes.']}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"CRI is Essential on Control Plane Nodes\u2014But with Exceptions:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When control plane components (like API Server, Controller Manager, and etcd) run as ",(0,i.jsx)(n.strong,{children:"static pods"}),", a ",(0,i.jsx)(n.strong,{children:"Container Runtime Interface (CRI) is required because Kubelet manages them as containers."})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"However, in some Kubernetes setups (e.g., certain managed services or custom-built clusters), control plane components run as systemd services instead of static pods. In such cases, the control plane can function without a CRI."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Despite this exception, ",(0,i.jsx)(n.strong,{children:"most Kubernetes distributions rely on static pods, making CRI a fundamental requirement for both control plane and worker nodes."})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Even if the control plane runs without a CRI, worker nodes still require it to manage application workloads."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Step 1: Check if the Control Plane Uses CRI"}),"\r\nRun:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"kubectl get pods -n kube-system\n"})}),"\n",(0,i.jsx)(n.p,{children:"Expected Output (If CRI is Present):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"NAME                               READY   STATUS    RESTARTS   AGE\r\nkube-apiserver-control-plane       1/1     Running   0          5m\r\netcd-control-plane                 1/1     Running   0          5m\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If these pods are missing or stuck in ",(0,i.jsx)(n.code,{children:"ContainerCreating"}),", it likely means CRI is missing."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Step 2: Verify CRI Connectivity"}),"\r\nRun:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"crictl ps\n"})}),"\n",(0,i.jsx)(n.p,{children:"Expected Output (If CRI is Missing):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"E0205 10:22:34.123456   1234 runtime.go:300] no runtime configured\n"})}),"\n",(0,i.jsx)(n.p,{children:"Confirming that the control plane needs a CRI just like worker nodes."}),"\n",(0,i.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CRI is required on all nodes where Kubernetes components run as containers,"})," including control plane nodes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Control plane components (like API Server, etcd, and Controller Manager) run as static pods"})," in most Kubernetes setups, requiring a container runtime."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Some Kubernetes distributions run control plane components as systemd services,"})," in which case CRI is not needed on control plane nodes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Without a CRI, kubeadm cannot initialize the cluster,"})," and critical control plane services won\u2019t start if they rely on containers."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Understanding CRI\u2019s role helps in troubleshooting missing services and failed cluster initialization issues."})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var r=t(6540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);