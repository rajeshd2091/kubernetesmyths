"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[2716],{557:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"k8s-core-myths/scheduling-myhd/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod","title":"Myth: A Higher-Priority Pod Will Always Preempt a Lower-Priority Pod","description":"I once reviewed an incident where a team created a high-priority pod expecting it to preempt other pods on the node. When the cluster stayed fully packed and the new pod remained unscheduled, they concluded \u201cpreemption is broken.\u201d","source":"@site/docs/k8s-core-myths/scheduling-myhd/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod.md","sourceDirName":"k8s-core-myths/scheduling-myhd","slug":"/k8s-core-myths/scheduling-myhd/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod","permalink":"/k8s-core-myths/scheduling-myhd/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-core-myths/scheduling-myhd/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"k8sCoreMythsSidebar","previous":{"title":"Myth: Kubernetes Scheduler Considers Resource Limits for Scheduling","permalink":"/k8s-core-myths/scheduling-myhd/Kubernetes_Scheduler_Considers_Resource_Limits_for_Scheduling"}}');var t=r(4848),s=r(8453);const o={sidebar_position:3},l="Myth: A Higher-Priority Pod Will Always Preempt a Lower-Priority Pod",d={},a=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Source of Truth",id:"source-of-truth",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"myth-a-higher-priority-pod-will-always-preempt-a-lower-priority-pod",children:"Myth: A Higher-Priority Pod Will Always Preempt a Lower-Priority Pod"})}),"\n",(0,t.jsx)(n.p,{children:"I once reviewed an incident where a team created a high-priority pod expecting it to preempt other pods on the node. When the cluster stayed fully packed and the new pod remained unscheduled, they concluded \u201cpreemption is broken.\u201d"}),"\n",(0,t.jsx)(n.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,t.jsx)(n.p,{children:"Because most examples in documentation and blogs refer to the default behavior of PriorityClass where preemption is allowed. This makes people think:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u201cHigher priority = automatic preemption.\u201d"})}),"\n",(0,t.jsx)(n.p,{children:"They never notice there is a separate field:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-makefile",children:"preemptionPolicy: Never\n"})}),"\n",(0,t.jsx)(n.p,{children:"This silently disables preemption but still keeps the high priority value \u2014 causing confusion."}),"\n",(0,t.jsx)(n.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,t.jsxs)(n.p,{children:["A higher-priority pod ",(0,t.jsx)(n.strong,{children:"does not automatically preempt lower-priority pods"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"It depends entirely on the PriorityClass preemption policy."}),"\n",(0,t.jsx)(n.p,{children:"If preemptionPolicy is omitted or set to default:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-makefile",children:"preemptionPolicy: PreemptLowerPriority\n"})}),"\n",(0,t.jsx)(n.p,{children:"Higher-priority pods can preempt lower-priority pods."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-makefile",children:"preemptionPolicy: Never\n"})}),"\n",(0,t.jsx)(n.p,{children:"Higher-priority pods cannot preempt anything \u2014 even if the node is full."}),"\n",(0,t.jsx)(n.p,{children:"They simply remain unschedulable."}),"\n",(0,t.jsx)(n.p,{children:"The scheduler will not:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"evict lower-priority pods"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"move pods"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"reshuffle nodes"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It behaves like a normal pod with a very high priority number but without the power to preempt."}),"\n",(0,t.jsx)(n.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Cluster setup used for this experiment:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Cluster hase only one node."}),"\n",(0,t.jsx)(n.li,{children:"Node has ~700m CPU available (very little free CPU)."}),"\n",(0,t.jsx)(n.li,{children:"Scheduler is default."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Step 1: Create Low-Priority Class"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: scheduling.k8s.io/v1\r\nkind: PriorityClass\r\nmetadata:\r\n  name: low\r\nvalue: 1000\r\nglobalDefault: false\n"})}),"\n",(0,t.jsx)(n.p,{children:"Apply:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"kubectl apply -f low.yaml\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Step 2: Create A Low-Priority Pods to Fill CPU"})}),"\n",(0,t.jsx)(n.p,{children:"Pod requests 600m CPU so the node becomes fully packed (700m total)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: low-1\r\nspec:\r\n  priorityClassName: low\r\n  containers:\r\n  - name: c\r\n    image: nginx\r\n    resources:\r\n      requests:\r\n        cpu: "600m"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Apply:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"kubectl apply -f low-pods.yaml\n"})}),"\n",(0,t.jsx)(n.p,{children:"Verify:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"kubectl get pod -o wide\r\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"Pod get scheduled and Running"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Step 3: Create a High Priority But NON-PREEMPTING PriorityClass"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: scheduling.k8s.io/v1\r\nkind: PriorityClass\r\nmetadata:\r\n  name: high-nonpreempt\r\nvalue: 100000\r\npreemptionPolicy: Never\r\nglobalDefault: false\n"})}),"\n",(0,t.jsx)(n.p,{children:"Apply:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"kubectl apply -f high-nonpreempt.yaml\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Step 4: Create High Priority Pod That Needs CPU"})}),"\n",(0,t.jsx)(n.p,{children:"This pod requires 500m CPU, but there is ~100 CPU available."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: high-nonpreempting-pod\r\nspec:\r\n  priorityClassName: high-nonpreempt\r\n  containers:\r\n  - name: c\r\n    image: nginx\r\n    resources:\r\n      requests:\r\n        cpu: "500m"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Apply:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"kubectl apply -f nonpreempting-pod.yaml\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Step 5: Observe Its State"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"kubectl describe pod high-nonpreempting-pod\r\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"You will see:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"Events:\r\n  Type     Reason            Age   From               Message\r\n  ----     ------            ----  ----               -------\r\n  Warning  FailedScheduling  18s   default-scheduler  0/1 nodes are available: 1 Insufficient cpu. preemption: not eligible due to preemptionPolicy=Never.\r\n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"No lower-priority pods are evicted."})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"No scheduling happens."})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Pod stays Pending forever."})}),"\n",(0,t.jsx)(n.h3,{id:"source-of-truth",children:"Source of Truth"}),"\n",(0,t.jsx)(n.p,{children:"Kubernetes source code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// PodEligibleToPreemptOthers returns one bool and one string. The bool\r\n// indicates whether this pod should be considered for preempting other pods or\r\n// not. The string includes the reason if this pod isn\'t eligible.\r\n// There\'re several reasons:\r\n//  1. The pod has a preemptionPolicy of Never.\r\n//  2. The pod has already preempted other pods and the victims are in their graceful termination period.\r\n//     Currently we check the node that is nominated for this pod, and as long as there are\r\n//     terminating pods on this node, we don\'t attempt to preempt more pods.\r\nfunc (pl *DefaultPreemption) PodEligibleToPreemptOthers(_ context.Context, pod *v1.Pod, nominatedNodeStatus *fwk.Status) (bool, string) {\r\n\tif pod.Spec.PreemptionPolicy != nil && *pod.Spec.PreemptionPolicy == v1.PreemptNever {\r\n\t\treturn false, "not eligible due to preemptionPolicy=Never."\r\n\t}\r\n\r\n\tnodeInfos := pl.fh.SnapshotSharedLister().NodeInfos()\r\n\tnomNodeName := pod.Status.NominatedNodeName\r\n\tif len(nomNodeName) > 0 {\r\n\t\t// If the pod\'s nominated node is considered as UnschedulableAndUnresolvable by the filters,\r\n\t\t// then the pod should be considered for preempting again.\r\n\t\tif nominatedNodeStatus.Code() == fwk.UnschedulableAndUnresolvable {\r\n\t\t\treturn true, ""\r\n\t\t}\r\n\r\n\t\tif nodeInfo, _ := nodeInfos.Get(nomNodeName); nodeInfo != nil {\r\n\t\t\tfor _, p := range nodeInfo.GetPods() {\r\n\t\t\t\tif pl.isPreemptionAllowed(nodeInfo, p, pod) && podTerminatingByPreemption(p.GetPod()) {\r\n\t\t\t\t\t// There is a terminating pod on the nominated node.\r\n\t\t\t\t\treturn false, "not eligible due to a terminating pod on the nominated node."\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true, ""\r\n}\r\n\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/framework/plugins/defaultpreemption/default_preemption.go#L309C1-L342C1",children:"View Kubernetes Source Code"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/framework/plugins/defaultpreemption/default_preemption.go#L309C1-L342C1\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Higher priority does not guarantee preemption."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Preemption works only when preemptionPolicy allows it."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"NonPreempting pods behave like normal pods even with very high priority."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Misconfigured PriorityClass often leads to \u201cscheduler is broken\u201d confusion."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Always verify if a PriorityClass is preempting or non-preempting."}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var i=r(6540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);