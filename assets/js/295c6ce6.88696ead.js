"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[716],{8453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>a});var i=t(6540);const r={},n=i.createContext(r);function o(e){const s=i.useContext(n);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(n.Provider,{value:s},e.children)}},9230:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"security_myths/overview","title":"Overview","description":"Kubernetes security is often misunderstood, not because the platform is insecure, but because its design principles differ from traditional infrastructure and application security models. Many teams assume Kubernetes automatically provides strong isolation, network safety, secure defaults, or hardened workloads. In reality, Kubernetes only offers building blocks\u2014misinterpreting these building blocks leads to configuration gaps, risky deployments, and a false sense of security.","source":"@site/docs/security_myths/overview.md","sourceDirName":"security_myths","slug":"/security_myths/overview","permalink":"/security_myths/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/security_myths/overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"overview","title":"Overview","sidebar_label":"Overview","sidebar":"securitySidebar","sidebar_position":1},"sidebar":"securitySidebar","next":{"title":"Myth: Kubernetes Namespaces Provide Complete Isolation","permalink":"/security_myths/Kubernetes_Namespaces_Provide_Complete_Isolation"}}');var r=t(4848),n=t(8453);const o={id:"overview",title:"Overview",sidebar_label:"Overview",sidebar:"securitySidebar",sidebar_position:1},a="Kubernetes Security Myths",c={},l=[{value:"Myths",id:"myths",level:2}];function u(e){const s={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"kubernetes-security-myths",children:"Kubernetes Security Myths"})}),"\n",(0,r.jsx)(s.p,{children:"Kubernetes security is often misunderstood, not because the platform is insecure, but because its design principles differ from traditional infrastructure and application security models. Many teams assume Kubernetes automatically provides strong isolation, network safety, secure defaults, or hardened workloads. In reality, Kubernetes only offers building blocks\u2014misinterpreting these building blocks leads to configuration gaps, risky deployments, and a false sense of security."}),"\n",(0,r.jsx)(s.p,{children:"This section examines the most common security-related misconceptions that lead to real-world vulnerabilities. Each myth is broken down using practical examples, technical explanations, and reproducible experiments. The goal is to clarify how Kubernetes security actually works, where responsibilities lie, and what assumptions commonly break secure-by-default thinking."}),"\n",(0,r.jsx)(s.p,{children:"By understanding and correcting these myths, engineers can avoid design flaws, reduce attack surfaces, and build security controls aligned with how Kubernetes truly operates."}),"\n",(0,r.jsx)(s.h2,{id:"myths",children:"Myths"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"/security_myths/Kubernetes_Namespaces_Provide_Complete_Isolation",children:"Kubernetes Namespaces Provide Complete Isolation"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"/security_myths/Kubernetes_Service_Accounts_Pull_Container_Images",children:"Kubernetes Service Accounts Pull Container Images"})}),"\n",(0,r.jsx)(s.li,{children:"Kubernetes Always Injects the Default Service Account Into Every Pod"}),"\n"]})]})}function d(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);