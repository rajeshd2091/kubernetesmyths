"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[5070],{8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>o});var r=i(6540);const s={},t=r.createContext(s);function a(n){const e=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),r.createElement(t.Provider,{value:e},n.children)}},8867:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"k8s-core-myths/pod-and-container-myths/Init_Containers_can_run_in_any_order_or_in_parallel","title":"Myth: Init Containers can run in any order or in parallel","description":"This myth often surfaces during interviews or design discussions:","source":"@site/docs/k8s-core-myths/pod-and-container-myths/Init_Containers_can_run_in_any_order_or_in_parallel.md","sourceDirName":"k8s-core-myths/pod-and-container-myths","slug":"/k8s-core-myths/pod-and-container-myths/Init_Containers_can_run_in_any_order_or_in_parallel","permalink":"/k8s-core-myths/pod-and-container-myths/Init_Containers_can_run_in_any_order_or_in_parallel","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-core-myths/pod-and-container-myths/Init_Containers_can_run_in_any_order_or_in_parallel.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"k8sCoreMythsSidebar","previous":{"title":"Myth: Pods Don\u2019t Consume Compute Resources Because They Are Logical","permalink":"/k8s-core-myths/pod-and-container-myths/Pods_Don\u2019t_Consume_Compute_Resources_Because_They_Are_Logical"},"next":{"title":"Myth: Kubernetes Pods Always Need a Service Account","permalink":"/k8s-core-myths/pod-and-container-myths/Kubernetes_Pods_Always_Need_a_Service_Account"}}');var s=i(4848),t=i(8453);const a={sidebar_position:4},o="Myth: Init Containers can run in any order or in parallel",l={},c=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality:",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function d(n){const e={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"myth-init-containers-can-run-in-any-order-or-in-parallel",children:"Myth: Init Containers can run in any order or in parallel"})}),"\n",(0,s.jsx)(e.p,{children:"This myth often surfaces during interviews or design discussions:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.em,{children:"\u201cWe\u2019ll use multiple init containers to speed things up. They can run in parallel anyway.\u201d"})}),"\n",(0,s.jsx)(e.p,{children:"In real clusters, this assumption leads to confusion:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Pods stuck in Init:0/2"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Long startup times"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Engineers debugging \u201cslow Kubernetes\u201d instead of incorrect expectations"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"The issue isn\u2019t Kubernetes performance \u2014 it\u2019s misunderstanding how init containers actually work."}),"\n",(0,s.jsx)(e.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Confusion with regular containers"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Application containers within a Pod can run in parallel, so people assume init containers behave the same way."}),"\n",(0,s.jsxs)(e.ol,{start:"2",children:["\n",(0,s.jsx)(e.li,{children:"The word \u2018container\u2019 hides the lifecycle difference"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Init containers look like normal containers in YAML, but they have a very different execution model."}),"\n",(0,s.jsxs)(e.ol,{start:"3",children:["\n",(0,s.jsx)(e.li,{children:"Lack of visibility into Pod startup phases"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Most users notice init containers only when a Pod is stuck, not when it works correctly."}),"\n",(0,s.jsx)(e.h3,{id:"the-reality",children:"The Reality:"}),"\n",(0,s.jsx)(e.p,{children:"Init containers always run sequentially, in the exact order defined in:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"spec.initContainers[]\n"})}),"\n",(0,s.jsx)(e.p,{children:"Kubernetes enforces this order strictly."}),"\n",(0,s.jsx)(e.p,{children:"That means:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Init containers never run in parallel"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Kubernetes starts the next init container only after the previous one completes successfully"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"The main application containers do not start at all until every init container has finished"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"This behavior is guaranteed and not configurable."}),"\n",(0,s.jsx)(e.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Step 1: Create a Pod with 3 container"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:'apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: init-order-demo\r\nspec:\r\n  restartPolicy: Never\r\n  initContainers:\r\n    - name: init-1\r\n      image: busybox\r\n      command: ["sh", "-c", "echo Init Container 1; sleep 3"]\r\n\r\n    - name: init-2\r\n      image: busybox\r\n      command: ["sh", "-c", "echo Init Container 2; sleep 3"]\r\n\r\n    - name: init-3\r\n      image: busybox\r\n      command: ["sh", "-c", "echo Init Container 3; sleep 3"]\r\n\r\n  containers:\r\n    - name: app\r\n      image: busybox\r\n      command: ["sh", "-c", "echo Main Application Container; sleep 3600"]\r\n\n'})}),"\n",(0,s.jsx)(e.p,{children:"Apply it:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sh",children:"kubectl apply -f init-order-demo.yaml\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Step 2: Check the Pod logs"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sh",children:"kubectl logs init-order-demo\n"})}),"\n",(0,s.jsx)(e.p,{children:"You will see output"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-sh",children:"Init Container 1\r\nInit Container 2\r\nInit Container 3\n"})}),"\n",(0,s.jsx)(e.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Init containers never run in parallel"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"They always execute one after another, in order"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"A failing init container restarts the Pod from the beginning"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Application containers start only after all init containers complete"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Init containers are dependency enforcers, not performance optimizers"}),"\n"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);