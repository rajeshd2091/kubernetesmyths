"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[6673],{1687:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","title":"Myth: ReadWriteOnce mode allows only a single Pod to access the volume","description":"During one of my interviews, the panel asked me, \u201cWhy does Kubernetes restrict RWO volumes to a single Pod?\u201d","source":"@site/docs/k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume.md","sourceDirName":"k8s-core-myths/storage-myths","slug":"/k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","permalink":"/k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume.md","tags":[],"version":"current","frontMatter":{},"sidebar":"k8sCoreMythsSidebar","previous":{"title":"Myth: Kubernetes PersistentVolumeClaim Can Be Resized","permalink":"/k8s-core-myths/storage-myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized"},"next":{"title":"Security Myths","permalink":"/category/security-myths"}}');var o=s(4848),a=s(8453);const r={},i="Myth: ReadWriteOnce mode allows only a single Pod to access the volume",l={},d=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function c(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsxs)(n.h1,{id:"myth-readwriteonce-mode-allows-only-a-single-pod-to-access-the-volume",children:["Myth: ",(0,o.jsx)(n.code,{children:"ReadWriteOnce"})," mode allows only a single Pod to access the volume"]})}),"\n",(0,o.jsx)(n.p,{children:"During one of my interviews, the panel asked me, \u201cWhy does Kubernetes restrict RWO volumes to a single Pod?\u201d\r\nI confidently answered, \u201cBecause only one Pod can mount it \u2014 that\u2019s what RWO means.\u201d\r\nThe interviewer smiled and said, \u201cAre you sure? What if those Pods are on the same node?\u201d"}),"\n",(0,o.jsx)(n.p,{children:"That question triggered me to revisit the actual behavior, and I realized how widely this myth is believed."}),"\n",(0,o.jsx)(n.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"For many years, Kubernetes only had ReadWriteOnce (RWO),"})," and there was no access mode that enforced single-Pod exclusivity until ReadWriteOncePod (RWOP) was introduced."]}),"\n",(0,o.jsxs)(n.li,{children:["Most developers interpret RWO literally \u2014 ",(0,o.jsx)(n.strong,{children:"\u201conly one Pod can write.\u201d"})]}),"\n",(0,o.jsx)(n.li,{children:"Documentation often states \u201cRWO = mounted by a single node,\u201d which many people convert in their head to \u201csingle Pod.\u201d"}),"\n",(0,o.jsx)(n.li,{children:"In everyday clusters, Pods with the same volume usually get scheduled on different nodes, making it look like Kubernetes enforces a single-Pod restriction."}),"\n",(0,o.jsx)(n.li,{children:"Because of this pattern, people assume that RWO inherently blocks multiple Pods."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,o.jsx)(n.p,{children:"ReadWriteOnce (RWO) means the volume can be mounted by only a single node at a time, not a single Pod."}),"\n",(0,o.jsx)(n.p,{children:"If multiple Pods run on the same node, they can simultaneously mount the same RWO PersistentVolumeClaim."}),"\n",(0,o.jsx)(n.p,{children:"To avoid this confusion, Kubernetes also introduced a more strict access mode:"}),"\n",(0,o.jsx)(n.p,{children:"ReadWriteOncePod (RWOP) \u2013 the volume can be mounted as read-write by only a single Pod, even if multiple Pods are on the same node.\r\nThis mode enforces the \u201cexactly one Pod only\u201d behavior that many people mistakenly assume RWO provides."}),"\n",(0,o.jsx)(n.p,{children:"Key points:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"RWO = single node restriction, multiple Pods allowed on that node."}),"\n",(0,o.jsx)(n.li,{children:"RWOP = single Pod restriction, even on the same node."}),"\n",(0,o.jsx)(n.li,{children:"RWOP is stricter and guarantees true single-writer semantics at Pod level."}),"\n",(0,o.jsx)(n.li,{children:"If Pods are scheduled to different nodes, both RWO and RWOP will trigger the same multi-attach error."}),"\n",(0,o.jsx)(n.li,{children:"RWOP makes the access rule explicit, solving the long-standing confusion around RWO."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Step1: Create a PVC with RWO"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\r\nkind: PersistentVolumeClaim\r\nmetadata:\r\n  name: rwo-pvc\r\nspec:\r\n  accessModes:\r\n    - ReadWriteOnce\r\n  resources:\r\n    requests:\r\n      storage: 1Gi\r\n\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Step 2: Create two Pods that both mount the same PVC"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: pod-a\r\nspec:\r\n  volumes:\r\n    - name: data\r\n      persistentVolumeClaim:\r\n        claimName: rwo-pvc\r\n  containers:\r\n    - name: app\r\n      image: alpine\r\n      command: ["sh", "-c", "sleep 3600"]\r\n      volumeMounts:\r\n        - mountPath: "/data"\r\n          name: data\r\n---\r\napiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n  name: pod-b\r\nspec:\r\n  volumes:\r\n    - name: data\r\n      persistentVolumeClaim:\r\n        claimName: rwo-pvc\r\n  containers:\r\n    - name: app\r\n      image: alpine\r\n      command: ["sh", "-c", "sleep 3600"]\r\n      volumeMounts:\r\n        - mountPath: "/data"\r\n          name: data\r\n\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Step 3: Force both Pods on the same node"}),"\r\nAdd this to both Pod specs if needed:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"nodeSelector:\r\n  kubernetes.io/hostname: <same-node-name>\r\n\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Step 4: Observe"})}),"\n",(0,o.jsx)(n.p,{children:"Both Pods will start successfully and mount the same RWO volume."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Step 5: Now move one Pod to another node"})}),"\n",(0,o.jsx)(n.p,{children:"Change the nodeSelector of pod-b to a different node."}),"\n",(0,o.jsx)(n.p,{children:"Result:\r\nThe second Pod will fail to start with an error similar to:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sh",children:"You\u2019ll see both **fast-default** and **slow-default** marked as default. No error. No warning.\n"})}),"\n",(0,o.jsx)(n.p,{children:"This confirms that the lock is at the node level, not the Pod level."}),"\n",(0,o.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"ReadWriteOnce restricts a volume to a single node, not a single Pod."}),"\n",(0,o.jsx)(n.li,{children:"Multiple Pods on the same node can mount the same RWO PVC simultaneously."}),"\n",(0,o.jsx)(n.li,{children:"Multi-Pod failures occur only when Pods land on different nodes, causing a block device multi-attach conflict."}),"\n",(0,o.jsx)(n.li,{children:"Understanding this helps design workloads like StatefulSets, Jobs, and shared-process Pods more effectively."}),"\n",(0,o.jsx)(n.li,{children:"RWO is a node-level access mode, not a Pod-level limitation."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>i});var t=s(6540);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);