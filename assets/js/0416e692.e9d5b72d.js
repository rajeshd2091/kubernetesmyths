"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1122],{425:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"k8s-core-myths/architecture-myths/Garbage_collector_deletes_images_as_soon_as_pods_stop_using_them","title":"Myth: Image Garbage collector deletes images as soon as pods stop using them","description":"During a release freeze, a team deleted several large batch workloads that were using 1\u20132 GB images.","source":"@site/docs/k8s-core-myths/architecture-myths/Garbage_collector_deletes_images_as_soon_as_pods_stop_using_them.md","sourceDirName":"k8s-core-myths/architecture-myths","slug":"/k8s-core-myths/architecture-myths/Garbage_collector_deletes_images_as_soon_as_pods_stop_using_them","permalink":"/k8s-core-myths/architecture-myths/Garbage_collector_deletes_images_as_soon_as_pods_stop_using_them","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-core-myths/architecture-myths/Garbage_collector_deletes_images_as_soon_as_pods_stop_using_them.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"k8sCoreMythsSidebar","previous":{"title":"Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime","permalink":"/k8s-core-myths/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime"},"next":{"title":"Myth: Image Garbage collector runs only when disk usage crosses a High-Threshold","permalink":"/k8s-core-myths/architecture-myths/Image_Garbage_collector_runs_only_when_disk_usage_crosses_a_High-Threshold"}}');var r=n(4848),i=n(8453);const a={sidebar_position:5},o="Myth: Image Garbage collector deletes images as soon as pods stop using them",l={},d=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Source of Truth",id:"source-of-truth",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"myth-image-garbage-collector-deletes-images-as-soon-as-pods-stop-using-them",children:"Myth: Image Garbage collector deletes images as soon as pods stop using them"})}),"\n",(0,r.jsx)(s.p,{children:"During a release freeze, a team deleted several large batch workloads that were using 1\u20132 GB images.\r\nThe assumption was simple:"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.em,{children:"\u201cJobs are gone. Images should be gone too. Disk will free up automatically.\u201d"})}),"\n",(0,r.jsx)(s.p,{children:"Two days later, a completely unrelated deployment started failing with:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-sh",children:"Failed to pull image\r\nno space left on device\n"})}),"\n",(0,r.jsx)(s.p,{children:"Everyone was confused:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"No pods were running"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Old workloads were already deleted"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Yet the node disk was almost full"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"When they logged into the node, they found dozens of unused images, some not used for weeks."}),"\n",(0,r.jsx)(s.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Other Kubernetes garbage collectors delete orphaned objects immediately"}),"\n",(0,r.jsx)(s.p,{children:"Resources like Pods, ReplicaSets, and Jobs are cleaned up promptly once they are no longer referenced, creating the expectation that images behave the same way."}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Confusion between pod lifecycle and image lifecycle"}),"\n",(0,r.jsx)(s.p,{children:"Pods are API objects managed by controllers, while images are node-local artifacts managed by kubelet, but this distinction is often overlooked."}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Experience with Docker workflows where images are manually pruned"}),"\n",(0,r.jsx)(s.p,{children:"Local Docker environments encourage frequent image cleanup using commands like docker image prune, leading users to assume Kubernetes does this automatically."}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Assumption that Kubernetes \u201cautomatically cleans everything\u201d"}),"\n",(0,r.jsx)(s.p,{children:"Kubernetes is often perceived as a self-managing system, masking the fact that many cleanups are reactive and threshold-driven rather than continuous."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,r.jsx)(s.p,{children:"Kubernetes does not delete images when pods stop using them."}),"\n",(0,r.jsx)(s.p,{children:"Image Garbage Collection is:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Triggered by disk pressure, not by pod deletion"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Managed entirely by kubelet, not controllers"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"The primary trigger is disk usage crossing:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"imageGCHighThresholdPercent (default: 85%)"})}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Once triggered, kubelet deletes unused images until usage drops below:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"imageGCLowThresholdPercent (default: 80%)"})}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"In addition to disk thresholds, kubelet applies age-based guards:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Minimum image age (MinAge)"})}),"\n",(0,r.jsx)(s.p,{children:"Newly pulled images are protected from deletion for a short duration to avoid delete\u2013pull loops during rapid restarts."}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Maximum image age (MaxAge)"})}),"\n",(0,r.jsx)(s.p,{children:"Images unused for longer than this duration are considered stronger deletion candidates."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"source-of-truth",children:"Source of Truth"}),"\n",(0,r.jsx)(s.p,{children:"Kubernetes source code:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-go",children:'    // If over the max threshold, free enough to place us at the lower threshold.\r\n\tusagePercent := 100 - int(available*100/capacity)\r\n\tif usagePercent >= im.policy.HighThresholdPercent {\r\n\t\tamountToFree := capacity*int64(100-im.policy.LowThresholdPercent)/100 - available\r\n\t\tlogger.Info("Disk usage on image filesystem is over the high threshold, trying to free bytes down to the low threshold", "usage", usagePercent, "highThreshold", im.policy.HighThresholdPercent, "amountToFree", amountToFree, "lowThreshold", im.policy.LowThresholdPercent)\r\n\t\tremainingImages, freed, err := im.freeSpace(ctx, amountToFree, freeTime, images)\r\n\t\tif err != nil {\r\n\t\t\t// Failed to delete images, eg due to a read-only filesystem.\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\tim.runPostGCHooks(ctx, remainingImages, freeTime)\r\n\r\n\t\tif freed < amountToFree {\r\n\t\t\t// This usually means the disk is full for reasons other than container\r\n\t\t\t// images, such as logs, volumes, or other files. However, it could also\r\n\t\t\t// be due to an unusually large number or size of in-use container images.\r\n\t\t\tmessage := fmt.Sprintf("Insufficient free disk space on the node\'s image filesystem (%d%% of %s used). "+\r\n\t\t\t\t"Failed to free sufficient space by deleting unused images (freed %d bytes). "+\r\n\t\t\t\t"Investigate disk usage, as it could be used by active images, logs, volumes, or other data.",\r\n\t\t\t\tusagePercent, formatSize(capacity), freed)\r\n\t\t\tim.recorder.Eventf(im.nodeRef, v1.EventTypeWarning, events.FreeDiskSpaceFailed, "%s", message)\r\n\t\t\treturn fmt.Errorf("%s", message)\r\n\t\t}\r\n\t}\r\n\n'})}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/images/image_gc_manager.go#L390C1-L414C3",children:"View Kubernetes Image GC Manager Source Code"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-sh",children:"https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/images/image_gc_manager.go#L390C1-L414C3\n"})}),"\n",(0,r.jsx)(s.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Pod deletion does not trigger image deletion"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Image GC is disk-pressure or Image Age driven"}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsx)(s.p,{children:"Unused images can accumulate for a long time"}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var t=n(6540);const r={},i=t.createContext(r);function a(e){const s=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);