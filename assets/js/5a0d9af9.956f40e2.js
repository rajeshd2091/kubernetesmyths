"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[5436],{4069:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","title":"Myth: ClusterIP Service Always Use Round-Robin Load Balancing","description":"Have you ever assumed that your pods are getting equal traffic? Many engineers believe Kubernetes distributes traffic evenly across pods in a strict round-robin manner. But if you actually monitor request distribution, you\u2019ll notice something surprising\u2014some pods receive more traffic than others. Is Kubernetes failing at load balancing? Not really. It turns out that the default behavior isn\'t what most people expect.","source":"@site/docs/k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing.md","sourceDirName":"k8s-core-myths/networking-myths","slug":"/k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","permalink":"/k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"k8sCoreMythsSidebar","previous":{"title":"Myth: ClusterIP Service is Only for Internal Traffic","permalink":"/k8s-core-myths/networking-myths/ClusterIP_Service_is_Only_for_Internal_Traffic"},"next":{"title":"Myth: \'kubectl port-forward svc\' sends traffic to a service","permalink":"/k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service"}}');var s=t(4848),i=t(8453);const o={sidebar_position:4},a="Myth: ClusterIP Service Always Use Round-Robin Load Balancing",l={},c=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function d(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"myth-clusterip-service-always-use-round-robin-load-balancing",children:"Myth: ClusterIP Service Always Use Round-Robin Load Balancing"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Have you ever assumed that your pods are getting equal traffic?"})," Many engineers believe Kubernetes distributes traffic evenly across pods in a strict round-robin manner. But if you actually monitor request distribution, you\u2019ll notice something surprising\u2014some pods receive more traffic than others. Is Kubernetes failing at load balancing? Not really. It turns out that the default behavior isn't what most people expect."]}),"\n",(0,s.jsx)(n.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"People assume Kubernetes works like traditional load balancers, which often default to round-robin."}),"\n",(0,s.jsx)(n.li,{children:"The presence of multiple backend pods creates an expectation of even traffic distribution."}),"\n",(0,s.jsx)(n.li,{children:"The internal working of kube-proxy is often overlooked"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,s.jsx)(n.p,{children:"The default iptables-based kube-proxy does not use round-robin. Instead, it relies on random probability-based selection when forwarding traffic to backend pods."}),"\n",(0,s.jsx)(n.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,s.jsx)(n.p,{children:"Step 1: Create a ClusterIP Service with Multiple Pods\r\nApply the following YAML:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"apiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  name: test-clusterip\r\nspec:\r\n  selector:\r\n    app: test-app\r\n  ports:\r\n    - protocol: TCP\r\n      port: 80\r\n      targetPort: 8080\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"apiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: test-app\r\nspec:\r\n  replicas: 3\r\n  selector:\r\n    matchLabels:\r\n      app: test-app\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: test-app\r\n    spec:\r\n      containers:\r\n        - name: app\r\n          image: nginx\r\n          ports:\r\n            - containerPort: 8080\r\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"Step 1: Send Requests and Observe the Pattern\r\nRun multiple requests from a test pod:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kubectl run test --rm -it --image=busybox -- /bin/sh\n"})}),"\n",(0,s.jsx)(n.p,{children:"Inside the pod, execute:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"while true; do wget -qO- http://test-clusterip.default.svc.cluster.local; sleep 1; done\n"})}),"\n",(0,s.jsx)(n.p,{children:"#TODO - Include Kiali image\r\nYou'll notice that some pods receive more traffic than others\u2014proving that the selection is random and not round-robin."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ClusterIP does not guarantee round-robin load balancing"}),"\u2014default iptables mode uses random selection."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IPVS mode can enable true round-robin scheduling"})," in Kubernetes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"External load balancers"})," provide more fine-grained control if round-robin is essential."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);