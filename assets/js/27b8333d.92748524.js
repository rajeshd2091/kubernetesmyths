"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[7863],{6023:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment","title":"Myth: Kubernetes Automatically Roll Back Failed Deployment","description":"A team deployed a new version of their application, expecting Kubernetes to roll it back automatically if something went wrong. Unfortunately, the deployment failed, but instead of rolling back, Kubernetes left it in a bad state. The team was surprised\u2014wasn\'t Kubernetes supposed to handle this automatically?","source":"@site/docs/k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment.md","sourceDirName":"k8s-core-myths/workload-myths","slug":"/k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment","permalink":"/k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"k8sCoreMythsSidebar","previous":{"title":"Myth: Deployment Supports All Pod Restart Policies","permalink":"/k8s-core-myths/workload-myths/Deployment_Supports_All_Pod_Restart_Policies"},"next":{"title":"Myth: Kubernetes always injects information about Services into a Pod","permalink":"/k8s-core-myths/workload-myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var"}}');var s=t(4848),r=t(8453);const o={sidebar_position:6},i="Myth: Kubernetes Automatically Roll Back Failed Deployment",a={},d=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function c(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"myth-kubernetes-automatically-roll-back-failed-deployment",children:"Myth: Kubernetes Automatically Roll Back Failed Deployment"})}),"\n",(0,s.jsx)(n.p,{children:"A team deployed a new version of their application, expecting Kubernetes to roll it back automatically if something went wrong. Unfortunately, the deployment failed, but instead of rolling back, Kubernetes left it in a bad state. The team was surprised\u2014wasn't Kubernetes supposed to handle this automatically?"}),"\n",(0,s.jsx)(n.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,s.jsx)(n.p,{children:"This misunderstanding comes from:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Expectation from Traditional Systems"})," \u2013 Some deployment tools provide automatic rollback mechanisms, leading users to assume Kubernetes does the same."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Confusion with Health Checks"})," \u2013 Kubernetes can stop bad deployments using readiness and liveness probes, but stopping an update is different from rolling back."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rollback Feature Misinterpretation"})," \u2013 Since ",(0,s.jsx)(n.code,{children:"kubectl rollout undo"})," exists, people assume Kubernetes triggers it automatically."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Expectation from CI/CD Pipelines"})," \u2013 Some CI/CD tools like ArgoCD and Spinnaker offer auto-rollbacks, making users think Kubernetes itself provides this feature."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Misunderstanding"})," ",(0,s.jsx)(n.code,{children:"progressDeadlineSeconds"})," \u2013 Many believe setting ",(0,s.jsx)(n.code,{children:"progressDeadlineSeconds"})," triggers an automatic rollback, but it only marks the deployment as failed."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,s.jsx)(n.p,{children:"Kubernetes does not automatically roll back a failed Deployment. While it detects failures, it requires manual intervention to revert to a previous version.Here\u2019s what actually happens:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If a Deployment update fails, Kubernetes pauses further updates but does not roll back."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["You must manually trigger a rollback using ",(0,s.jsx)(n.code,{children:"kubectl rollout undo deployment <name>"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Kubernetes tracks revisions, but rollbacks only work for Deployments\u2014they do not revert ConfigMaps, Secrets, or Persistent Volumes."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"progressDeadlineSeconds"})," plays a crucial role \u2013 If a rollout does not complete within the configured ",(0,s.jsx)(n.code,{children:"progressDeadlineSeconds"}),", the Deployment is marked as failed, but Kubernetes does not roll it back automatically. Instead, the rollout gets paused, requiring manual intervention."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,s.jsx)(n.p,{children:"Step 1: Create a Working Deployment"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"apiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: nginx-deployment\r\nspec:\r\n  replicas: 2\r\n  strategy:\r\n    type: RollingUpdate\r\n    rollingUpdate:\r\n      maxUnavailable: 1\r\n  progressDeadlineSeconds: 30\r\n  selector:\r\n    matchLabels:\r\n      app: nginx\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: nginx\r\n    spec:\r\n      containers:\r\n        - name: nginx\r\n          image: nginx:latest\r\n          ports:\r\n            - containerPort: 80\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply the Deployment:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kubectl apply -f nginx-deployment.yaml\r\nkubectl rollout status deployment/nginx-deployment\n"})}),"\n",(0,s.jsx)(n.p,{children:"This should show a successful rollout."}),"\n",(0,s.jsx)(n.p,{children:"Step 2: Trigger a Failed Deployment\r\nNow, let's break the deployment by using an invalid container image."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"apiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: nginx-deployment\r\nspec:\r\n  replicas: 2\r\n  strategy:\r\n    type: RollingUpdate\r\n    rollingUpdate:\r\n      maxUnavailable: 1\r\n  progressDeadlineSeconds: 30\r\n  selector:\r\n    matchLabels:\r\n      app: nginx\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: nginx\r\n    spec:\r\n      containers:\r\n        - name: nginx\r\n          image: nginx:doesnotexist  # Invalid image\r\n          ports:\r\n            - containerPort: 80\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply the broken Deployment:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kubectl apply -f nginx-deployment.yaml\n"})}),"\n",(0,s.jsx)(n.p,{children:"Check the rollout status:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kubectl rollout status deployment/nginx-deployment --timeout=60s\r\nkubectl rollout status deployment/nginx-deployment --timeout=60s\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After ",(0,s.jsx)(n.code,{children:"progressDeadlineSeconds"})," (30 seconds in this case), Kubernetes will mark the Deployment as failed, but it won\u2019t roll back automatically."]}),"\n",(0,s.jsx)(n.p,{children:"Step 3: Verify That Kubernetes Does Not Roll Back\r\nCheck the rollout history:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kubectl rollout history deployment/nginx-deployment\n"})}),"\n",(0,s.jsx)(n.p,{children:"You'll see that Kubernetes has not reverted to the previous working version."}),"\n",(0,s.jsx)(n.p,{children:"Check the deployment status:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kubectl get deployment nginx-deployment -o jsonpath='{.status.conditions}'\n"})}),"\n",(0,s.jsx)(n.p,{children:"The output will show a ProgressDeadlineExceeded condition but no rollback."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Kubernetes does not automatically roll back a failed Deployment."}),"\n",(0,s.jsx)(n.li,{children:"You must manually trigger a rollback if needed."}),"\n",(0,s.jsx)(n.li,{children:"progressDeadlineSeconds only marks a deployment as failed but does not roll it back."}),"\n",(0,s.jsx)(n.li,{children:"CI/CD tools can be configured to handle rollback logic."}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var l=t(6540);const s={},r=l.createContext(s);function o(e){const n=l.useContext(r);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),l.createElement(r.Provider,{value:n},e.children)}}}]);