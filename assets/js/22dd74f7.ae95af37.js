"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1567],{5226:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"k8sCoreMythsSidebar":[{"type":"category","label":"Architecture Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes","label":"Myth: Kubelet is Exclusive to Worker Nodes","docId":"k8s-core-myths/architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy","label":"Myth: Kubernetes Clusters Can\'t Function Without Kube-Proxy","docId":"k8s-core-myths/architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin","label":"Myth: Kubernetes Networking Works Fine Without a CNI Plugin","docId":"k8s-core-myths/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","label":"Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime","docId":"k8s-core-myths/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Kubernetes_Cluster_Must_Have_Three_Control_Plane_Nodes","label":"Myth: Kubernetes Cluster Must Have Three Control Plane Nodes","docId":"k8s-core-myths/architecture-myths/Kubernetes_Cluster_Must_Have_Three_Control_Plane_Nodes","unlisted":false}],"href":"/category/architecture-myths"},{"type":"category","label":"Workload Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/workload-myths/Complete_application_can_be_rolled_back_in_Kubernetes","label":"Myth: Complete application can be rolled back in Kubernetes","docId":"k8s-core-myths/workload-myths/Complete_application_can_be_rolled_back_in_Kubernetes","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/Rolling_Updates_Are_Only_Supported_by_Deployments","label":"Myth: Rolling Updates Are Only Supported by Deployments","docId":"k8s-core-myths/workload-myths/Rolling_Updates_Are_Only_Supported_by_Deployments","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/DaemonSet_always_schedule_pods_on_all_nodes","label":"Myth: DaemonSet always schedule pods on all nodes.","docId":"k8s-core-myths/workload-myths/DaemonSet_always_schedule_pods_on_all_nodes","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/Deployment_Supports_All_Pod_Restart_Policies","label":"Myth: Deployment Supports All Pod Restart Policies","docId":"k8s-core-myths/workload-myths/Deployment_Supports_All_Pod_Restart_Policies","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment","label":"Myth: Kubernetes Automatically Roll Back Failed Deployment","docId":"k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var","label":"Myth: Kubernetes always injects information about Services into a Pod","docId":"k8s-core-myths/workload-myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var","unlisted":false}],"href":"/category/workload-myths"},{"type":"category","label":"Networking Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/networking-myths/kube_proxy_assign_IP_address_to_Pods","label":"Myth: kube-proxy assign IP address to Pods","docId":"k8s-core-myths/networking-myths/kube_proxy_assign_IP_address_to_Pods","unlisted":false},{"type":"link","href":"/k8s-core-myths/networking-myths/ClusterIP_Service_is_Only_for_Internal_Traffic","label":"Myth: ClusterIP Service is Only for Internal Traffic","docId":"k8s-core-myths/networking-myths/ClusterIP_Service_is_Only_for_Internal_Traffic","unlisted":false},{"type":"link","href":"/k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","label":"Myth: ClusterIP Service Always Use Round-Robin Load Balancing","docId":"k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","unlisted":false},{"type":"link","href":"/k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service","label":"Myth: \'kubectl port-forward svc\' sends traffic to a service","docId":"k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service","unlisted":false},{"type":"link","href":"/k8s-core-myths/networking-myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet","label":"Myth: NodePort Service Always Exposes the Application to the Internet","docId":"k8s-core-myths/networking-myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet","unlisted":false}],"href":"/category/networking-myths"},{"type":"category","label":"Storage Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/storage-myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass","label":"Myth: Kubernetes Cluster Can Have Only One Default StorageClass","docId":"k8s-core-myths/storage-myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass","unlisted":false},{"type":"link","href":"/k8s-core-myths/storage-myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized","label":"Myth: Kubernetes PersistentVolumeClaim Can Be Resized","docId":"k8s-core-myths/storage-myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized","unlisted":false},{"type":"link","href":"/k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","label":"Myth: ReadWriteOnce mode allows only a single Pod to access the volume","docId":"k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","unlisted":false}],"href":"/category/storage-myths"},{"type":"category","label":"Security Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/security-myths/Kubernetes_Namespaces_Provide_Complete_Isolation","label":"Myth: Kubernetes Namespaces Provide Complete Isolation","docId":"k8s-core-myths/security-myths/Kubernetes_Namespaces_Provide_Complete_Isolation","unlisted":false},{"type":"link","href":"/k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images","label":"Myth: Kubernetes Service Accounts Pull Container Images","docId":"k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images","unlisted":false}],"href":"/category/security-myths"},{"type":"category","label":"Scheduling Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/scheduling-myhd/Kubernetes_Scheduler_Considers_Resource_Limits_for_Scheduling","label":"Myth: Kubernetes Scheduler Considers Resource Limits for Scheduling","docId":"k8s-core-myths/scheduling-myhd/Kubernetes_Scheduler_Considers_Resource_Limits_for_Scheduling","unlisted":false},{"type":"link","href":"/k8s-core-myths/scheduling-myhd/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod","label":"Myth: A Higher-Priority Pod Will Always Preempt a Lower-Priority Pod","docId":"k8s-core-myths/scheduling-myhd/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod","unlisted":false}],"href":"/category/scheduling-myths"}],"k8sEcosystemMythsSidebar":[{"type":"category","label":"Container Image Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build once_deploy_anywhere","label":"Myth: Container images truly support \u201cbuild once, deploy anywhere\\"","docId":"k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build once_deploy_anywhere","unlisted":false}],"href":"/category/container-image-myths"},{"type":"category","label":"OCI Registry Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-ecosystem-myths/oci-registry-myths/OCI_Registries_Only_Support_Container_Images","label":"Myth: OCI Registries Only Support Container Images","docId":"k8s-ecosystem-myths/oci-registry-myths/OCI_Registries_Only_Support_Container_Images","unlisted":false}],"href":"/category/oci-registry-myths"}],"k8sPlatformMythsSidebar":[{"type":"link","href":"/k8s-platform-myths/","label":"Platform Myths","docId":"k8s-platform-myths/platform-myths","unlisted":false}],"k8sDomainMythsSidebar":[{"type":"link","href":"/k8s-domain-myths/","label":"K8s Domain Myths","docId":"k8s-domain-myths/domain-myths","unlisted":false}]},"docs":{"intro":{"id":"intro","title":"Tutorial Intro","description":"Let\'s discover Docusaurus in less than 5 minutes."},"k8s-core-myths/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime":{"id":"k8s-core-myths/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","title":"Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime","description":"You set up your control plane node, confident that everything is configured correctly. Next, you run kubeadm init, expecting a smooth setup\u2014but it fails instantly!","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes":{"id":"k8s-core-myths/architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes","title":"Myth: Kubelet is Exclusive to Worker Nodes","description":"You SSH into a control plane node, expecting to see only control plane components like the API server, controller manager, and scheduler running. But wait\u2014why is Kubelet there? Wasn\'t it supposed to run only on worker nodes?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Kubernetes_Cluster_Must_Have_Three_Control_Plane_Nodes":{"id":"k8s-core-myths/architecture-myths/Kubernetes_Cluster_Must_Have_Three_Control_Plane_Nodes","title":"Myth: Kubernetes Cluster Must Have Three Control Plane Nodes","description":"Coming Soon ...","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy":{"id":"k8s-core-myths/architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy","title":"Myth: Kubernetes Clusters Can\'t Function Without Kube-Proxy","description":"You deploy a Kubernetes cluster and start checking the usual system components. API server? Running. Controller manager? Running. Kube-Proxy? Wait\u2026 it\'s missing! You double-check the namespace, logs, and even the deployment\u2014nothing. But surprisingly, your pods and services are still communicating just fine. How is this possible? Isn\'t Kube-Proxy essential for cluster networking?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin":{"id":"k8s-core-myths/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin","title":"Myth: Kubernetes Networking Works Fine Without a CNI Plugin","description":"You set up a Production Kubernetes cluster, deploy some pods, and\u2026 nothing. They can\'t talk to each other, You search Stack Overflow, try restarting pods, but nothing works, Finally, you realize networking is broken, and some pods are stuck in \\"ContainerCreating\\" state. You check the logs and see:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/ClusterIP_Service_is_Only_for_Internal_Traffic":{"id":"k8s-core-myths/networking-myths/ClusterIP_Service_is_Only_for_Internal_Traffic","title":"Myth: ClusterIP Service is Only for Internal Traffic","description":"You\u2019ve just configured a ClusterIP service to expose one of your pods internally in your Kubernetes cluster. It seems like a straightforward setup\u2014after all, ClusterIP services are meant to route traffic between pods within the cluster, right? So, you assume that it\u2019s all about internal communication.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing":{"id":"k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","title":"Myth: ClusterIP Service Always Use Round-Robin Load Balancing","description":"Have you ever assumed that your pods are getting equal traffic? Many engineers believe Kubernetes distributes traffic evenly across pods in a strict round-robin manner. But if you actually monitor request distribution, you\u2019ll notice something surprising\u2014some pods receive more traffic than others. Is Kubernetes failing at load balancing? Not really. It turns out that the default behavior isn\'t what most people expect.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/kube_proxy_assign_IP_address_to_Pods":{"id":"k8s-core-myths/networking-myths/kube_proxy_assign_IP_address_to_Pods","title":"Myth: kube-proxy assign IP address to Pods","description":"A common belief among Kubernetes users is that kube-proxy is responsible for assigning IP addresses to pods. After all, it manages networking rules and enables communication between services\u2014so it must be the component handling pod IPs, right?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service":{"id":"k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service","title":"Myth: \'kubectl port-forward svc\' sends traffic to a service","description":"Many engineers assume that running:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet":{"id":"k8s-core-myths/networking-myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet","title":"Myth: NodePort Service Always Exposes the Application to the Internet","description":"During a production debugging call, a team raised an urgent security concern:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/scheduling-myhd/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod":{"id":"k8s-core-myths/scheduling-myhd/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod","title":"Myth: A Higher-Priority Pod Will Always Preempt a Lower-Priority Pod","description":"I once reviewed an incident where a team created a high-priority pod expecting it to preempt other pods on the node. When the cluster stayed fully packed and the new pod remained unscheduled, they concluded \u201cpreemption is broken.\u201d","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/scheduling-myhd/Kubernetes_Scheduler_Considers_Resource_Limits_for_Scheduling":{"id":"k8s-core-myths/scheduling-myhd/Kubernetes_Scheduler_Considers_Resource_Limits_for_Scheduling","title":"Myth: Kubernetes Scheduler Considers Resource Limits for Scheduling","description":"During a design review in a large-scale cluster, I once noticed a deployment configured with extremely low requests but very high limits. Engineers expected the scheduler to recognize the pod\'s potential to burst and avoid scheduling it on already constrained nodes. However, the pod was consistently placed on small nodes, causing CPU throttling and memory contention. This led to a debate where several team members argued that the scheduler must be considering limits, actual usage, or both. The issue highlighted a widespread misunderstanding about how Kubernetes decides resource placement.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/security-myths/Kubernetes_Namespaces_Provide_Complete_Isolation":{"id":"k8s-core-myths/security-myths/Kubernetes_Namespaces_Provide_Complete_Isolation","title":"Myth: Kubernetes Namespaces Provide Complete Isolation","description":"Many teams assume that creating separate namespaces guarantees strong isolation between workloads, preventing them from affecting each other. But this belief can lead to critical security oversights.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images":{"id":"k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images","title":"Myth: Kubernetes Service Accounts Pull Container Images","description":"During internal security audits and team discussions, several engineers assumed that ServiceAccounts were used to authenticate with container registries. One developer even tried granting additional RBAC permissions to a ServiceAccount in an attempt to fix an image-pull failure from a private registry. The issue persisted, and only later did the team realize that the ServiceAccount had no role in image retrieval at all. The failure was caused by missing imagePullSecrets, not ServiceAccount permissions.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/storage-myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass":{"id":"k8s-core-myths/storage-myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass","title":"Myth: Kubernetes Cluster Can Have Only One Default StorageClass","description":"You\'re defining a new StorageClass and set:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/storage-myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized":{"id":"k8s-core-myths/storage-myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized","title":"Myth: Kubernetes PersistentVolumeClaim Can Be Resized","description":"During a design discussion, a team member confidently stated that \u201cPVCs in Kubernetes are fully resizable \u2014 you can increase or decrease storage whenever you want.\u201d This assumption influenced their storage planning and automated cleanup strategy.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume":{"id":"k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","title":"Myth: ReadWriteOnce mode allows only a single Pod to access the volume","description":"During one of my interviews, the panel asked me, \u201cWhy does Kubernetes restrict RWO volumes to a single Pod?\u201d","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/Complete_application_can_be_rolled_back_in_Kubernetes":{"id":"k8s-core-myths/workload-myths/Complete_application_can_be_rolled_back_in_Kubernetes","title":"Myth: Complete application can be rolled back in Kubernetes","description":"A team deployed a new version of their microservices-based application in Kubernetes. Soon after, they noticed critical issues and decided to roll back using:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/DaemonSet_always_schedule_pods_on_all_nodes":{"id":"k8s-core-myths/workload-myths/DaemonSet_always_schedule_pods_on_all_nodes","title":"Myth: DaemonSet always schedule pods on all nodes.","description":"Expect DaemonSet to Run on Every Node? Not So Fast! Many assume that a DaemonSet automatically schedules a Pod on every node in the cluster. While this is generally true, there are several cases where DaemonSet does not schedule Pods on all nodes.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/Deployment_Supports_All_Pod_Restart_Policies":{"id":"k8s-core-myths/workload-myths/Deployment_Supports_All_Pod_Restart_Policies","title":"Myth: Deployment Supports All Pod Restart Policies","description":"Can You Use Any Restart Policy in a Deployment?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var":{"id":"k8s-core-myths/workload-myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var","title":"Myth: Kubernetes always injects information about Services into a Pod","description":"I was attending a free Kubernetes webinar where the speaker was walking through service discovery patterns.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment":{"id":"k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment","title":"Myth: Kubernetes Automatically Roll Back Failed Deployment","description":"A team deployed a new version of their application, expecting Kubernetes to roll it back automatically if something went wrong. Unfortunately, the deployment failed, but instead of rolling back, Kubernetes left it in a bad state. The team was surprised\u2014wasn\'t Kubernetes supposed to handle this automatically?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/Rolling_Updates_Are_Only_Supported_by_Deployments":{"id":"k8s-core-myths/workload-myths/Rolling_Updates_Are_Only_Supported_by_Deployments","title":"Myth: Rolling Updates Are Only Supported by Deployments","description":"Many believe that rolling updates are an exclusive feature of Kubernetes Deployments. This assumption leads to the misconception that StatefulSets and DaemonSets do not support rolling updates, forcing teams to use workarounds. But is this really the case?","sidebar":"k8sCoreMythsSidebar"},"k8s-domain-myths/domain-myths":{"id":"k8s-domain-myths/domain-myths","title":"K8s Domain Myths","description":"We\u2019re building the Kubernetes Domain Myths section! Please Stay tuned for insights","sidebar":"k8sDomainMythsSidebar"},"k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build once_deploy_anywhere":{"id":"k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build once_deploy_anywhere","title":"Myth: Container images truly support \u201cbuild once, deploy anywhere\\"","description":"This statement is frequently repeated in container and DevOps communities. Many engineers confidently claim that once a container image is built, it can run on any machine or Kubernetes cluster, regardless of the underlying hardware.During discussions with developers and SREs, this belief appears almost universally accepted.","sidebar":"k8sEcosystemMythsSidebar"},"k8s-ecosystem-myths/oci-registry-myths/OCI_Registries_Only_Support_Container_Images":{"id":"k8s-ecosystem-myths/oci-registry-myths/OCI_Registries_Only_Support_Container_Images","title":"Myth: OCI Registries Only Support Container Images","description":"During an internal platform engineering discussion, a developer challenged me:","sidebar":"k8sEcosystemMythsSidebar"},"k8s-platform-myths/platform-myths":{"id":"k8s-platform-myths/platform-myths","title":"Platform Myths","description":"We\u2019re building the Kubernetes Platform Myths section!","sidebar":"k8sPlatformMythsSidebar"},"the-kubernetes-mythologist":{"id":"the-kubernetes-mythologist","title":"The Kubernetes Mythologist","description":"Meet Rajesh Deshpande \u2014 decoding Kubernetes myths with experiments, source code, and production insights."}}}}')}}]);