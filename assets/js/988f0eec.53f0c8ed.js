"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[4491],{6239:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"k8s-domain-myths/sre/Kubernetes-Guarantees-Application-Self-Healing","title":"Myth: Kubernetes Guarantees Application Self-Healing","description":"During an on-call incident, alerts showed pods continuously restarting, nodes were healthy, and Kubernetes reported everything as \u201cRunning.\u201d","source":"@site/docs/k8s-domain-myths/sre/Kubernetes-Guarantees-Application-Self-Healing.md","sourceDirName":"k8s-domain-myths/sre","slug":"/k8s-domain-myths/sre/Kubernetes-Guarantees-Application-Self-Healing","permalink":"/k8s-domain-myths/sre/Kubernetes-Guarantees-Application-Self-Healing","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/k8s-domain-myths/sre/Kubernetes-Guarantees-Application-Self-Healing.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"k8sDomainMythsSidebar","previous":{"title":"SRE Myths","permalink":"/category/sre-myths"}}');var r=s(4848),t=s(8453);const l={sidebar_position:2},a="Myth: Kubernetes Guarantees Application Self-Healing",c={},o=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"myth-kubernetes-guarantees-application-self-healing",children:"Myth: Kubernetes Guarantees Application Self-Healing"})}),"\n",(0,r.jsx)(n.p,{children:"During an on-call incident, alerts showed pods continuously restarting, nodes were healthy, and Kubernetes reported everything as \u201cRunning.\u201d"}),"\n",(0,r.jsx)(n.p,{children:"Yet users were still seeing errors and timeouts."}),"\n",(0,r.jsx)(n.p,{children:"The common conclusion during the incident review was:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"\u201cKubernetes should have self-healed this.\u201d"})}),"\n",(0,r.jsx)(n.p,{children:"It hadn\u2019t."}),"\n",(0,r.jsx)(n.p,{children:"It simply kept restarting the same broken application."}),"\n",(0,r.jsx)(n.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,r.jsx)(n.p,{children:"This myth is reinforced by Kubernetes features that appear intelligent:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Controllers continuously reconcile desired state"}),"\n",(0,r.jsx)(n.li,{children:"Pods are automatically restarted on crashes"}),"\n",(0,r.jsx)(n.li,{children:"Failed nodes trigger pod rescheduling"}),"\n",(0,r.jsx)(n.li,{children:"Marketing and conference talks overuse the term self-healing"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Over time, this creates the belief that Kubernetes understands and heals application failures."}),"\n",(0,r.jsx)(n.p,{children:"It does not."}),"\n",(0,r.jsx)(n.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,r.jsx)(n.p,{children:"Kubernetes does not heal applications, it just restarts them."}),"\n",(0,r.jsx)(n.p,{children:"It enforces desired state."}),"\n",(0,r.jsx)(n.p,{children:"Kubernetes has no concept of:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Correct business behavior"}),"\n",(0,r.jsx)(n.li,{children:"Dependency health"}),"\n",(0,r.jsx)(n.li,{children:"Partial failures"}),"\n",(0,r.jsx)(n.li,{children:"Performance degradation"}),"\n",(0,r.jsx)(n.li,{children:"Data corruption"}),"\n",(0,r.jsx)(n.li,{children:"Logical deadlocks"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"From Kubernetes\u2019 perspective, an application is healthy as long as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The container process is running"}),"\n",(0,r.jsx)(n.li,{children:"Probes (if configured) return success"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If a pod is alive but wrong, Kubernetes considers the job done."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What Kubernetes Actually Self-Heals"})}),"\n",(0,r.jsx)(n.p,{children:"Kubernetes can recover from infrastructure-level symptoms:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Crashed container processes"}),"\n",(0,r.jsx)(n.li,{children:"Deleted pods"}),"\n",(0,r.jsx)(n.li,{children:"Node failures"}),"\n",(0,r.jsx)(n.li,{children:"Drift between desired and actual object state"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This is ",(0,r.jsx)(n.strong,{children:"process recovery"}),", not application healing."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What Kubernetes Cannot Self-Heal"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Misconfigurations"}),"\n",(0,r.jsx)(n.li,{children:"Memory leaks"}),"\n",(0,r.jsx)(n.li,{children:"Deadlocks"}),"\n",(0,r.jsx)(n.li,{children:"Slow or degraded responses"}),"\n",(0,r.jsx)(n.li,{children:"Broken downstream dependencies"}),"\n",(0,r.jsx)(n.li,{children:"Partial outages"}),"\n",(0,r.jsx)(n.li,{children:"Cascading failures"}),"\n",(0,r.jsx)(n.li,{children:"Incorrect application logic"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In many cases, Kubernetes restarts the application repeatedly, masking the real problem and delaying human intervention."}),"\n",(0,r.jsx)(n.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Scenario"})}),"\n",(0,r.jsx)(n.p,{children:"The application logs show errors."}),"\n",(0,r.jsx)(n.p,{children:"Kubernetes restarts the pod."}),"\n",(0,r.jsx)(n.p,{children:"After restart, the same error appears again."}),"\n",(0,r.jsx)(n.p,{children:"User impact continues."}),"\n",(0,r.jsx)(n.p,{children:"Yet Kubernetes reports the system as healthy."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Step 1: Deploy an Application That Fails Logically"})}),"\n",(0,r.jsx)(n.p,{children:"The application:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Starts successfully"}),"\n",(0,r.jsx)(n.li,{children:"Crashes after hitting a configuration error"}),"\n",(0,r.jsx)(n.li,{children:"Logs the same error every time it starts"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example behavior (what SREs see first \u2014 logs):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"ERROR: Failed to connect to database\r\nERROR: Invalid DB_HOST configuration\r\nExiting application\n"})}),"\n",(0,r.jsx)(n.p,{children:"The process exits, Kubernetes restarts it."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Step 2: Observe the Logs (Before Restart)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"kubectl logs -f pod/app-pod\n"})}),"\n",(0,r.jsx)(n.p,{children:"Output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"ERROR: Failed to connect to database\r\nERROR: Invalid DB_HOST configuration\r\nExiting application\n"})}),"\n",(0,r.jsx)(n.p,{children:"Pod crashes."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Step 3: Kubernetes \u201cSelf-Heals\u201d (Restarts the Pod)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"kubectl get pods\n"})}),"\n",(0,r.jsx)(n.p,{children:"Output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"NAME         READY   STATUS    RESTARTS   AGE\r\napp-pod      1/1     Running     3          1m\n"})}),"\n",(0,r.jsx)(n.p,{children:"From Kubernetes\u2019 perspective:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pod restarted"}),"\n",(0,r.jsx)(n.li,{children:"Pod running"}),"\n",(0,r.jsx)(n.li,{children:"Problem solved"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Step 4: Observe Logs After Restart"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"kubectl logs -f pod/app-pod\n"})}),"\n",(0,r.jsx)(n.p,{children:"Output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"ERROR: Failed to connect to database\r\nERROR: Invalid DB_HOST configuration\r\nExiting application\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Exact same error."}),"\r\n",(0,r.jsx)(n.strong,{children:"Exact same failure."}),"\r\n",(0,r.jsx)(n.strong,{children:"Exact same user impact."})]}),"\n",(0,r.jsx)(n.p,{children:"Kubernetes did not heal anything."}),"\n",(0,r.jsx)(n.p,{children:"It simply replayed the failure."}),"\n",(0,r.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Kubernetes is self-restarting, not self-healing"}),"\n",(0,r.jsx)(n.li,{children:"It heals infrastructure symptoms, not system failures"}),"\n",(0,r.jsx)(n.li,{children:"Application health is the responsibility of SREs and developers"}),"\n",(0,r.jsx)(n.li,{children:"Without proper probes, SLOs, and observability, self-healing becomes self-hiding"}),"\n",(0,r.jsx)(n.li,{children:"Reliability emerges from design, not from the platform alone"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);