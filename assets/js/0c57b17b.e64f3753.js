"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[816],{4912:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"networking_myths/ClusterIP_Service_is_Only_for_Internal_Traffic","title":"Myth: ClusterIP Service is Only for Internal Traffic","description":"You\u2019ve just configured a ClusterIP service to expose one of your pods internally in your Kubernetes cluster. It seems like a straightforward setup\u2014after all, ClusterIP services are meant to route traffic between pods within the cluster, right? So, you assume that it\u2019s all about internal communication.","source":"@site/docs/networking_myths/ClusterIP_Service_is_Only_for_Internal_Traffic.md","sourceDirName":"networking_myths","slug":"/networking_myths/ClusterIP_Service_is_Only_for_Internal_Traffic","permalink":"/networking_myths/ClusterIP_Service_is_Only_for_Internal_Traffic","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-myths/website/blob/main/docs/networking_myths/ClusterIP_Service_is_Only_for_Internal_Traffic.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"networkingSidebar","previous":{"title":"Myth: kube-proxy assign IP address to Pods","permalink":"/networking_myths/kube_proxy_assign_IP_address_to_Pods"},"next":{"title":"Myth: \'kubectl port-forward svc\' sends traffic to a service","permalink":"/networking_myths/kubectl_port-forward_svc_sends_traffic_to_a_service"}}');var n=r(4848),i=r(8453);const a={sidebar_position:3},l="Myth: ClusterIP Service is Only for Internal Traffic",o={},c=[{value:"Why This Myth Exists?",id:"why-this-myth-exists",level:3},{value:"The Reality",id:"the-reality",level:3},{value:"Experiment &amp; Validate",id:"experiment--validate",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function d(e){const t={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"myth-clusterip-service-is-only-for-internal-traffic",children:"Myth: ClusterIP Service is Only for Internal Traffic"})}),"\n",(0,n.jsx)(t.p,{children:"You\u2019ve just configured a ClusterIP service to expose one of your pods internally in your Kubernetes cluster. It seems like a straightforward setup\u2014after all, ClusterIP services are meant to route traffic between pods within the cluster, right? So, you assume that it\u2019s all about internal communication."}),"\n",(0,n.jsx)(t.p,{children:"But then, you decide to test it a bit more. You try accessing the service using a curl command from a different pod within the same cluster and\u2026 it works perfectly. That\u2019s expected, right? You start thinking that ClusterIP is only for internal use. But curiosity leads you to try something else\u2014accessing the service from outside the cluster."}),"\n",(0,n.jsx)(t.p,{children:"To your surprise, it works! You use a load balancer or a proxy to access the service, and your request is successfully routed to the ClusterIP service. Wait\u2014how can this be? ClusterIP should only be for internal traffic, right?"}),"\n",(0,n.jsx)(t.h3,{id:"why-this-myth-exists",children:"Why This Myth Exists?"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:'Kubernetes documentation emphasizes ClusterIP as an "internal" service type'})}),", leading people to overlook its role in external communication."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"NodePort and LoadBalancer are explicitly designed for external access"})}),", making it seem like ClusterIP plays no role in exposing services."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"Developers often misunderstand how Kubernetes routes traffic"})}),", missing the fact that external service types still forward traffic through ClusterIP."]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"the-reality",children:"The Reality"}),"\n",(0,n.jsx)(t.p,{children:"Yes, a pure ClusterIP service is internal, but every Kubernetes service\u2014whether NodePort or LoadBalancer\u2014relies on ClusterIP behind the scenes. Even when traffic comes from outside the cluster, it still flows through ClusterIP before reaching the pods."}),"\n",(0,n.jsx)(t.h3,{id:"experiment--validate",children:"Experiment & Validate"}),"\n",(0,n.jsx)(t.p,{children:"Step 1: Create a LoadBalancer Service\r\nApply the following YAML to create a LoadBalancer service:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:"apiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  name: my-loadbalancer-service\r\nspec:\r\n  selector:\r\n    app: my-app\r\n  ports:\r\n    - protocol: TCP\r\n      port: 80\r\n      targetPort: 8080\r\n  type: LoadBalancer\n"})}),"\n",(0,n.jsx)(t.p,{children:"Step 2: Verify the Created Service\r\nRun the following command to check the details of the service:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sh",children:"kubectl get svc my-loadbalancer-service -o wide\n"})}),"\n",(0,n.jsx)(t.p,{children:"Expected Output:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-pgsql",children:"NAME                      TYPE           CLUSTER-IP   EXTERNAL-IP   PORT(S)       AGE\r\nmy-loadbalancer-service   LoadBalancer   10.96.0.150  <pending>     80:32000/TCP  5s\n"})}),"\n",(0,n.jsx)(t.p,{children:"Notice the CLUSTER-IP field\u2014Kubernetes has automatically assigned a ClusterIP to the LoadBalancer service."}),"\n",(0,n.jsx)(t.p,{children:"Step 3: Confirm That ClusterIP Exists\r\nEven though the service is a LoadBalancer, it still functions like a ClusterIP service inside the cluster. You can verify this by running:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sh",children:"kubectl get endpoints my-loadbalancer-service\n"})}),"\n",(0,n.jsx)(t.p,{children:"Expected Output:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-nginx",children:"NAME                      ENDPOINTS           AGE\r\nmy-loadbalancer-service   192.168.1.100:8080  5s\n"})}),"\n",(0,n.jsx)(t.p,{children:"This proves that traffic is routed through the ClusterIP before reaching the pods."}),"\n",(0,n.jsx)(t.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"ClusterIP is not just for internal traffic; it is essential for external services like NodePort and LoadBalancer."}),"\n",(0,n.jsx)(t.li,{children:"Every Kubernetes service type ultimately forwards traffic through ClusterIP before reaching the pods."}),"\n",(0,n.jsx)(t.li,{children:"Misunderstanding ClusterIP\u2019s role can lead to unnecessary service type changes and wasted troubleshooting efforts."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>l});var s=r(6540);const n={},i=s.createContext(n);function a(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);