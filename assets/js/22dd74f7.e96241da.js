"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1567],{5226:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"k8sCoreMythsSidebar":[{"type":"category","label":"Architecture Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes","label":"Myth: Kubelet is Exclusive to Worker Nodes","docId":"k8s-core-myths/architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy","label":"Myth: Kubernetes Clusters Can\'t Function Without Kube-Proxy","docId":"k8s-core-myths/architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin","label":"Myth: Kubernetes Networking Works Fine Without a CNI Plugin","docId":"k8s-core-myths/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","label":"Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime","docId":"k8s-core-myths/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Garbage_collector_deletes_images_as_soon_as_pods_stop_using_them","label":"Myth: Image Garbage collector deletes images as soon as pods stop using them","docId":"k8s-core-myths/architecture-myths/Garbage_collector_deletes_images_as_soon_as_pods_stop_using_them","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Image_Garbage_collector_runs_only_when_disk_usage_crosses_a_High-Threshold","label":"Myth: Image Garbage collector runs only when disk usage crosses a High-Threshold","docId":"k8s-core-myths/architecture-myths/Image_Garbage_collector_runs_only_when_disk_usage_crosses_a_High-Threshold","unlisted":false},{"type":"link","href":"/k8s-core-myths/architecture-myths/Kubelet_can_modify_any_Kubernetes_object_through_the_API_server","label":"Myth: Kubelet can modify any Kubernetes object through the API server","docId":"k8s-core-myths/architecture-myths/Kubelet_can_modify_any_Kubernetes_object_through_the_API_server","unlisted":false}],"href":"/category/architecture-myths"},{"type":"category","label":"Workload Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/workload-myths/Complete_application_can_be_rolled_back_in_Kubernetes","label":"Myth: Complete application can be rolled back in Kubernetes","docId":"k8s-core-myths/workload-myths/Complete_application_can_be_rolled_back_in_Kubernetes","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/Rolling_Updates_Are_Only_Supported_by_Deployments","label":"Myth: Rolling Updates Are Only Supported by Deployments","docId":"k8s-core-myths/workload-myths/Rolling_Updates_Are_Only_Supported_by_Deployments","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/DaemonSet_always_schedule_pods_on_all_nodes","label":"Myth: DaemonSet always schedule pods on all nodes.","docId":"k8s-core-myths/workload-myths/DaemonSet_always_schedule_pods_on_all_nodes","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/Deployment_Supports_All_Pod_Restart_Policies","label":"Myth: Deployment Supports All Pod Restart Policies","docId":"k8s-core-myths/workload-myths/Deployment_Supports_All_Pod_Restart_Policies","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment","label":"Myth: Kubernetes Automatically Roll Back Failed Deployment","docId":"k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment","unlisted":false},{"type":"link","href":"/k8s-core-myths/workload-myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var","label":"Myth: Kubernetes always injects information about Services into a Pod","docId":"k8s-core-myths/workload-myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var","unlisted":false}],"href":"/category/workload-myths"},{"type":"category","label":"Networking Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/networking-myths/kube_proxy_assign_IP_address_to_Pods","label":"Myth: kube-proxy assign IP address to Pods","docId":"k8s-core-myths/networking-myths/kube_proxy_assign_IP_address_to_Pods","unlisted":false},{"type":"link","href":"/k8s-core-myths/networking-myths/ClusterIP_Service_is_Only_for_Internal_Traffic","label":"Myth: ClusterIP Service is Only for Internal Traffic","docId":"k8s-core-myths/networking-myths/ClusterIP_Service_is_Only_for_Internal_Traffic","unlisted":false},{"type":"link","href":"/k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","label":"Myth: ClusterIP Service Always Use Round-Robin Load Balancing","docId":"k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","unlisted":false},{"type":"link","href":"/k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service","label":"Myth: \'kubectl port-forward svc\' sends traffic to a service","docId":"k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service","unlisted":false},{"type":"link","href":"/k8s-core-myths/networking-myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet","label":"Myth: NodePort Service Always Exposes the Application to the Internet","docId":"k8s-core-myths/networking-myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet","unlisted":false}],"href":"/category/networking-myths"},{"type":"category","label":"Storage Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/storage-myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass","label":"Myth: Kubernetes Cluster Can Have Only One Default StorageClass","docId":"k8s-core-myths/storage-myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass","unlisted":false},{"type":"link","href":"/k8s-core-myths/storage-myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized","label":"Myth: Kubernetes PersistentVolumeClaim Can Be Resized","docId":"k8s-core-myths/storage-myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized","unlisted":false},{"type":"link","href":"/k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","label":"Myth: ReadWriteOnce mode allows only a single Pod to access the volume","docId":"k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","unlisted":false}],"href":"/category/storage-myths"},{"type":"category","label":"Pod and Container Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/pod-and-container-myths/Kubernetes_Has_Only_One_Pod_Type","label":"Myth: Kubernetes Has Only One Pod Type","docId":"k8s-core-myths/pod-and-container-myths/Kubernetes_Has_Only_One_Pod_Type","unlisted":false},{"type":"link","href":"/k8s-core-myths/pod-and-container-myths/Pods_Don\u2019t_Consume_Compute_Resources_Because_They_Are_Logical","label":"Myth: Pods Don\u2019t Consume Compute Resources Because They Are Logical","docId":"k8s-core-myths/pod-and-container-myths/Pods_Don\u2019t_Consume_Compute_Resources_Because_They_Are_Logical","unlisted":false},{"type":"link","href":"/k8s-core-myths/pod-and-container-myths/Init_Containers_can_run_in_any_order_or_in_parallel","label":"Myth: Init Containers can run in any order or in parallel","docId":"k8s-core-myths/pod-and-container-myths/Init_Containers_can_run_in_any_order_or_in_parallel","unlisted":false},{"type":"link","href":"/k8s-core-myths/pod-and-container-myths/Kubernetes_Pods_Always_Need_a_Service_Account","label":"Myth: Kubernetes Pods Always Need a Service Account","docId":"k8s-core-myths/pod-and-container-myths/Kubernetes_Pods_Always_Need_a_Service_Account","unlisted":false}],"href":"/category/pod-and-container-myths"},{"type":"category","label":"Security Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/security-myths/Kubernetes_Namespaces_Provide_Complete_Isolation","label":"Myth: Kubernetes Namespaces Provide Complete Isolation","docId":"k8s-core-myths/security-myths/Kubernetes_Namespaces_Provide_Complete_Isolation","unlisted":false},{"type":"link","href":"/k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images","label":"Myth: Kubernetes Service Accounts Pull Container Images","docId":"k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images","unlisted":false},{"type":"link","href":"/k8s-core-myths/security-myths/Pod_Security_Admission_enforces_security_on_running_Pods","label":"Myth: Pod Security Admission enforces security on running Pods","docId":"k8s-core-myths/security-myths/Pod_Security_Admission_enforces_security_on_running_Pods","unlisted":false}],"href":"/category/security-myths"},{"type":"category","label":"Scheduling Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-core-myths/scheduling-myths/Kubernetes_Scheduler_Considers_Resource_Limits_for_Scheduling","label":"Myth: Kubernetes Scheduler Considers Resource Limits for Scheduling","docId":"k8s-core-myths/scheduling-myths/Kubernetes_Scheduler_Considers_Resource_Limits_for_Scheduling","unlisted":false},{"type":"link","href":"/k8s-core-myths/scheduling-myths/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod","label":"Myth: A Higher-Priority Pod Will Always Preempt a Lower-Priority Pod","docId":"k8s-core-myths/scheduling-myths/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod","unlisted":false},{"type":"link","href":"/k8s-core-myths/scheduling-myths/Kubernetes_Has_a_Concept_of_Node_Anti-Affinity","label":"Myth: Kubernetes Has a Concept of Node Anti-Affinity","docId":"k8s-core-myths/scheduling-myths/Kubernetes_Has_a_Concept_of_Node_Anti-Affinity","unlisted":false},{"type":"link","href":"/k8s-core-myths/scheduling-myths/Pod_memory_requests_are_only_used_for_scheduling","label":"Myth: Pod memory requests are only used for scheduling","docId":"k8s-core-myths/scheduling-myths/Pod_memory_requests_are_only_used_for_scheduling","unlisted":false}],"href":"/category/scheduling-myths"}],"k8sEcosystemMythsSidebar":[{"type":"category","label":"Container Image Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build_once_deploy_anywhere","label":"Myth: Container images truly support \u201cbuild once, deploy anywhere\\"","docId":"k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build_once_deploy_anywhere","unlisted":false},{"type":"link","href":"/k8s-ecosystem-myths/container-image-myths/A_Container_Image_Digest_Uniquely_Identifies_One_Image","label":"Myth: A Container Image Digest Uniquely Identifies One Image","docId":"k8s-ecosystem-myths/container-image-myths/A_Container_Image_Digest_Uniquely_Identifies_One_Image","unlisted":false}],"href":"/category/container-image-myths"},{"type":"category","label":"OCI Registry Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-ecosystem-myths/oci-registry-myths/OCI_Registries_Only_Support_Container_Images","label":"Myth: OCI Registries Only Support Container Images","docId":"k8s-ecosystem-myths/oci-registry-myths/OCI_Registries_Only_Support_Container_Images","unlisted":false}],"href":"/category/oci-registry-myths"}],"k8sPlatformMythsSidebar":[{"type":"category","label":"Amazon EKS Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-platform-myths/amazon-eks-myths/EKS-Control-Plane-Performance-Can\u2019t-Be-Tuned","label":"Myth: EKS Control Plane Performance Can\u2019t Be Tuned","docId":"k8s-platform-myths/amazon-eks-myths/EKS-Control-Plane-Performance-Can\u2019t-Be-Tuned","unlisted":false}],"href":"/category/amazon-eks-myths"},{"type":"category","label":"Google GKE Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-platform-myths/google-gke-myths/GKE_Zonal_Clusters_Are_Cheaper_Than_Regional_Clusters","label":"Myth: GKE Zonal Clusters Are Cheaper Than Regional Clusters","docId":"k8s-platform-myths/google-gke-myths/GKE_Zonal_Clusters_Are_Cheaper_Than_Regional_Clusters","unlisted":false}],"href":"/category/google-gke-myths"}],"k8sDomainMythsSidebar":[{"type":"category","label":"Application Development Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-domain-myths/application-development/Applications-Don\u2019t-Need-Readiness-or-Liveness-Probes","label":"Myth: Applications Don\u2019t Need Readiness or Liveness Probes","docId":"k8s-domain-myths/application-development/Applications-Don\u2019t-Need-Readiness-or-Liveness-Probes","unlisted":false},{"type":"link","href":"/k8s-domain-myths/application-development/Kubernetes-Supports-In-Place-Application-Upgrades","label":"Myth: Kubernetes Supports In-Place Application Upgrades","docId":"k8s-domain-myths/application-development/Kubernetes-Supports-In-Place-Application-Upgrades","unlisted":false}],"href":"/category/application-development-myths"},{"type":"category","label":"SRE Myths","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/k8s-domain-myths/sre/Kubernetes-Guarantees-Application-Self-Healing","label":"Myth: Kubernetes Guarantees Application Self-Healing","docId":"k8s-domain-myths/sre/Kubernetes-Guarantees-Application-Self-Healing","unlisted":false}],"href":"/category/sre-myths"}]},"docs":{"intro":{"id":"intro","title":"Tutorial Intro","description":"Let\'s discover Docusaurus in less than 5 minutes."},"k8s-core-myths/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime":{"id":"k8s-core-myths/architecture-myths/Control_Plane_Nodes_Don\u2019t_Need_a_Container_Runtime","title":"Myth:  Control Plane Nodes Don\u2019t Need a Container Runtime","description":"You set up your control plane node, confident that everything is configured correctly. Next, you run kubeadm init, expecting a smooth setup\u2014but it fails instantly!","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Garbage_collector_deletes_images_as_soon_as_pods_stop_using_them":{"id":"k8s-core-myths/architecture-myths/Garbage_collector_deletes_images_as_soon_as_pods_stop_using_them","title":"Myth: Image Garbage collector deletes images as soon as pods stop using them","description":"During a release freeze, a team deleted several large batch workloads that were using 1\u20132 GB images.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Image_Garbage_collector_runs_only_when_disk_usage_crosses_a_High-Threshold":{"id":"k8s-core-myths/architecture-myths/Image_Garbage_collector_runs_only_when_disk_usage_crosses_a_High-Threshold","title":"Myth: Image Garbage collector runs only when disk usage crosses a High-Threshold","description":"During a node disk analysis in a long-running cluster, I noticed unused container images disappearing even though disk usage was well below the image GC high threshold.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Kubelet_can_modify_any_Kubernetes_object_through_the_API_server":{"id":"k8s-core-myths/architecture-myths/Kubelet_can_modify_any_Kubernetes_object_through_the_API_server","title":"Myth: Kubelet can modify any Kubernetes object through the API server","description":"I\u2019ve heard this statement multiple times in security reviews:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes":{"id":"k8s-core-myths/architecture-myths/Kubelet_is_Exclusive_to_Worker_Nodes","title":"Myth: Kubelet is Exclusive to Worker Nodes","description":"You SSH into a control plane node, expecting to see only control plane components like the API server, controller manager, and scheduler running. But wait\u2014why is Kubelet there? Wasn\'t it supposed to run only on worker nodes?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy":{"id":"k8s-core-myths/architecture-myths/Kubernetes_Clusters_Can\'t_Function_Without_Kube-Proxy","title":"Myth: Kubernetes Clusters Can\'t Function Without Kube-Proxy","description":"You deploy a Kubernetes cluster and start checking the usual system components. API server? Running. Controller manager? Running. Kube-Proxy? Wait\u2026 it\'s missing! You double-check the namespace, logs, and even the deployment\u2014nothing. But surprisingly, your pods and services are still communicating just fine. How is this possible? Isn\'t Kube-Proxy essential for cluster networking?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin":{"id":"k8s-core-myths/architecture-myths/Kubernetes_Networking_Works_Fine_Without_a_CNI_Plugin","title":"Myth: Kubernetes Networking Works Fine Without a CNI Plugin","description":"You set up a Production Kubernetes cluster, deploy some pods, and\u2026 nothing. They can\'t talk to each other, You search Stack Overflow, try restarting pods, but nothing works, Finally, you realize networking is broken, and some pods are stuck in \\"ContainerCreating\\" state. You check the logs and see:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/ClusterIP_Service_is_Only_for_Internal_Traffic":{"id":"k8s-core-myths/networking-myths/ClusterIP_Service_is_Only_for_Internal_Traffic","title":"Myth: ClusterIP Service is Only for Internal Traffic","description":"You\u2019ve just configured a ClusterIP service to expose one of your pods internally in your Kubernetes cluster. It seems like a straightforward setup\u2014after all, ClusterIP services are meant to route traffic between pods within the cluster, right? So, you assume that it\u2019s all about internal communication.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing":{"id":"k8s-core-myths/networking-myths/ClusterIP_Services_Always_Use_Round-Robin_Load_Balancing","title":"Myth: ClusterIP Service Always Use Round-Robin Load Balancing","description":"Have you ever assumed that your pods are getting equal traffic? Many engineers believe Kubernetes distributes traffic evenly across pods in a strict round-robin manner. But if you actually monitor request distribution, you\u2019ll notice something surprising\u2014some pods receive more traffic than others. Is Kubernetes failing at load balancing? Not really. It turns out that the default behavior isn\'t what most people expect.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/kube_proxy_assign_IP_address_to_Pods":{"id":"k8s-core-myths/networking-myths/kube_proxy_assign_IP_address_to_Pods","title":"Myth: kube-proxy assign IP address to Pods","description":"A common belief among Kubernetes users is that kube-proxy is responsible for assigning IP addresses to pods. After all, it manages networking rules and enables communication between services\u2014so it must be the component handling pod IPs, right?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service":{"id":"k8s-core-myths/networking-myths/kubectl_port-forward_svc_sends_traffic_to_a_service","title":"Myth: \'kubectl port-forward svc\' sends traffic to a service","description":"Many engineers assume that running:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/networking-myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet":{"id":"k8s-core-myths/networking-myths/NodePort_Service_Always_Exposes_the_Application_to_the_Internet","title":"Myth: NodePort Service Always Exposes the Application to the Internet","description":"During a production debugging call, a team raised an urgent security concern:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/pod-and-container-myths/Init_Containers_can_run_in_any_order_or_in_parallel":{"id":"k8s-core-myths/pod-and-container-myths/Init_Containers_can_run_in_any_order_or_in_parallel","title":"Myth: Init Containers can run in any order or in parallel","description":"This myth often surfaces during interviews or design discussions:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/pod-and-container-myths/Kubernetes_Has_Only_One_Pod_Type":{"id":"k8s-core-myths/pod-and-container-myths/Kubernetes_Has_Only_One_Pod_Type","title":"Myth: Kubernetes Has Only One Pod Type","description":"I\u2019ve heard this many times in interviews:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/pod-and-container-myths/Kubernetes_Pods_Always_Need_a_Service_Account":{"id":"k8s-core-myths/pod-and-container-myths/Kubernetes_Pods_Always_Need_a_Service_Account","title":"Myth: Kubernetes Pods Always Need a Service Account","description":"I\u2019ve seen engineers argue that disabling Service Account tokens is unsafe because \u201cpods need it to run.\u201d","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/pod-and-container-myths/Pods_Don\u2019t_Consume_Compute_Resources_Because_They_Are_Logical":{"id":"k8s-core-myths/pod-and-container-myths/Pods_Don\u2019t_Consume_Compute_Resources_Because_They_Are_Logical","title":"Myth: Pods Don\u2019t Consume Compute Resources Because They Are Logical","description":"This belief feels correct.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/scheduling-myths/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod":{"id":"k8s-core-myths/scheduling-myths/A_Higher-Priority_Pod_Will_Always_Preempt_a_Lower-Priority_Pod","title":"Myth: A Higher-Priority Pod Will Always Preempt a Lower-Priority Pod","description":"I once reviewed an incident where a team created a high-priority pod expecting it to preempt other pods on the node. When the cluster stayed fully packed and the new pod remained unscheduled, they concluded \u201cpreemption is broken.\u201d","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/scheduling-myths/Kubernetes_Has_a_Concept_of_Node_Anti-Affinity":{"id":"k8s-core-myths/scheduling-myths/Kubernetes_Has_a_Concept_of_Node_Anti-Affinity","title":"Myth: Kubernetes Has a Concept of Node Anti-Affinity","description":"During a platform engineering interview, a candidate was asked:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/scheduling-myths/Kubernetes_Scheduler_Considers_Resource_Limits_for_Scheduling":{"id":"k8s-core-myths/scheduling-myths/Kubernetes_Scheduler_Considers_Resource_Limits_for_Scheduling","title":"Myth: Kubernetes Scheduler Considers Resource Limits for Scheduling","description":"During a design review in a large-scale cluster, I once noticed a deployment configured with extremely low requests but very high limits. Engineers expected the scheduler to recognize the pod\'s potential to burst and avoid scheduling it on already constrained nodes. However, the pod was consistently placed on small nodes, causing CPU throttling and memory contention. This led to a debate where several team members argued that the scheduler must be considering limits, actual usage, or both. The issue highlighted a widespread misunderstanding about how Kubernetes decides resource placement.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/scheduling-myths/Pod_memory_requests_are_only_used_for_scheduling":{"id":"k8s-core-myths/scheduling-myths/Pod_memory_requests_are_only_used_for_scheduling","title":"Myth: Pod memory requests are only used for scheduling","description":"During an incident review, a team noticed that several Pods were evicted even though they were well below their configured memory limits.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/security-myths/Kubernetes_Namespaces_Provide_Complete_Isolation":{"id":"k8s-core-myths/security-myths/Kubernetes_Namespaces_Provide_Complete_Isolation","title":"Myth: Kubernetes Namespaces Provide Complete Isolation","description":"Many teams assume that creating separate namespaces guarantees strong isolation between workloads, preventing them from affecting each other. But this belief can lead to critical security oversights.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images":{"id":"k8s-core-myths/security-myths/Kubernetes_Service_Accounts_Pull_Container_Images","title":"Myth: Kubernetes Service Accounts Pull Container Images","description":"During internal security audits and team discussions, several engineers assumed that ServiceAccounts were used to authenticate with container registries. One developer even tried granting additional RBAC permissions to a ServiceAccount in an attempt to fix an image-pull failure from a private registry. The issue persisted, and only later did the team realize that the ServiceAccount had no role in image retrieval at all. The failure was caused by missing imagePullSecrets, not ServiceAccount permissions.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/security-myths/Pod_Security_Admission_enforces_security_on_running_Pods":{"id":"k8s-core-myths/security-myths/Pod_Security_Admission_enforces_security_on_running_Pods","title":"Myth: Pod Security Admission enforces security on running Pods","description":"During a production security review, a team proudly stated:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/storage-myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass":{"id":"k8s-core-myths/storage-myths/Kubernetes_Cluster_Can_Have_Only_One_Default_StorageClass","title":"Myth: Kubernetes Cluster Can Have Only One Default StorageClass","description":"You\'re defining a new StorageClass and set:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/storage-myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized":{"id":"k8s-core-myths/storage-myths/Kubernetes_PersistentVolumeClaim_Can_Be_Resized","title":"Myth: Kubernetes PersistentVolumeClaim Can Be Resized","description":"During a design discussion, a team member confidently stated that \u201cPVCs in Kubernetes are fully resizable \u2014 you can increase or decrease storage whenever you want.\u201d This assumption influenced their storage planning and automated cleanup strategy.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume":{"id":"k8s-core-myths/storage-myths/ReadWriteOnce_mode_allows_only_a_single_Pod_to_access_the_volume","title":"Myth: ReadWriteOnce mode allows only a single Pod to access the volume","description":"During one of my interviews, the panel asked me, \u201cWhy does Kubernetes restrict RWO volumes to a single Pod?\u201d","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/Complete_application_can_be_rolled_back_in_Kubernetes":{"id":"k8s-core-myths/workload-myths/Complete_application_can_be_rolled_back_in_Kubernetes","title":"Myth: Complete application can be rolled back in Kubernetes","description":"A team deployed a new version of their microservices-based application in Kubernetes. Soon after, they noticed critical issues and decided to roll back using:","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/DaemonSet_always_schedule_pods_on_all_nodes":{"id":"k8s-core-myths/workload-myths/DaemonSet_always_schedule_pods_on_all_nodes","title":"Myth: DaemonSet always schedule pods on all nodes.","description":"Expect DaemonSet to Run on Every Node? Not So Fast! Many assume that a DaemonSet automatically schedules a Pod on every node in the cluster. While this is generally true, there are several cases where DaemonSet does not schedule Pods on all nodes.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/Deployment_Supports_All_Pod_Restart_Policies":{"id":"k8s-core-myths/workload-myths/Deployment_Supports_All_Pod_Restart_Policies","title":"Myth: Deployment Supports All Pod Restart Policies","description":"Can You Use Any Restart Policy in a Deployment?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var":{"id":"k8s-core-myths/workload-myths/K8s_Injects_Svc_Info_Into_A_Pods_Env_Var","title":"Myth: Kubernetes always injects information about Services into a Pod","description":"I was attending a free Kubernetes webinar where the speaker was walking through service discovery patterns.","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment":{"id":"k8s-core-myths/workload-myths/Kubernetes_automatically_roll_back_failed_deployment","title":"Myth: Kubernetes Automatically Roll Back Failed Deployment","description":"A team deployed a new version of their application, expecting Kubernetes to roll it back automatically if something went wrong. Unfortunately, the deployment failed, but instead of rolling back, Kubernetes left it in a bad state. The team was surprised\u2014wasn\'t Kubernetes supposed to handle this automatically?","sidebar":"k8sCoreMythsSidebar"},"k8s-core-myths/workload-myths/Rolling_Updates_Are_Only_Supported_by_Deployments":{"id":"k8s-core-myths/workload-myths/Rolling_Updates_Are_Only_Supported_by_Deployments","title":"Myth: Rolling Updates Are Only Supported by Deployments","description":"Many believe that rolling updates are an exclusive feature of Kubernetes Deployments. This assumption leads to the misconception that StatefulSets and DaemonSets do not support rolling updates, forcing teams to use workarounds. But is this really the case?","sidebar":"k8sCoreMythsSidebar"},"k8s-domain-myths/application-development/Applications-Don\u2019t-Need-Readiness-or-Liveness-Probes":{"id":"k8s-domain-myths/application-development/Applications-Don\u2019t-Need-Readiness-or-Liveness-Probes","title":"Myth: Applications Don\u2019t Need Readiness or Liveness Probes","description":"A team deployed a microservice without readiness or liveness probes. In production, Pods started receiving traffic before fully initializing, causing immediate 500 errors. One Pod even hung during startup, but Kubernetes didn\u2019t restart it because there was no liveness probe.","sidebar":"k8sDomainMythsSidebar"},"k8s-domain-myths/application-development/Kubernetes-Supports-In-Place-Application-Upgrades":{"id":"k8s-domain-myths/application-development/Kubernetes-Supports-In-Place-Application-Upgrades","title":"Myth: Kubernetes Supports In-Place Application Upgrades","description":"In traditional server- or VM-based environments, upgrading an application usually meant updating binaries or packages on the same machine and restarting the process. The application instance remained the same; only its version changed.","sidebar":"k8sDomainMythsSidebar"},"k8s-domain-myths/sre/Kubernetes-Guarantees-Application-Self-Healing":{"id":"k8s-domain-myths/sre/Kubernetes-Guarantees-Application-Self-Healing","title":"Myth: Kubernetes Guarantees Application Self-Healing","description":"During an on-call incident, alerts showed pods continuously restarting, nodes were healthy, and Kubernetes reported everything as \u201cRunning.\u201d","sidebar":"k8sDomainMythsSidebar"},"k8s-ecosystem-myths/container-image-myths/A_Container_Image_Digest_Uniquely_Identifies_One_Image":{"id":"k8s-ecosystem-myths/container-image-myths/A_Container_Image_Digest_Uniquely_Identifies_One_Image","title":"Myth: A Container Image Digest Uniquely Identifies One Image","description":"When discussing container images, the term digest is often used without qualification:","sidebar":"k8sEcosystemMythsSidebar"},"k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build_once_deploy_anywhere":{"id":"k8s-ecosystem-myths/container-image-myths/Container_images_truly_support_build_once_deploy_anywhere","title":"Myth: Container images truly support \u201cbuild once, deploy anywhere\\"","description":"This statement is frequently repeated in container and DevOps communities. Many engineers confidently claim that once a container image is built, it can run on any machine or Kubernetes cluster, regardless of the underlying hardware.During discussions with developers and SREs, this belief appears almost universally accepted.","sidebar":"k8sEcosystemMythsSidebar"},"k8s-ecosystem-myths/oci-registry-myths/OCI_Registries_Only_Support_Container_Images":{"id":"k8s-ecosystem-myths/oci-registry-myths/OCI_Registries_Only_Support_Container_Images","title":"Myth: OCI Registries Only Support Container Images","description":"During an internal platform engineering discussion, a developer challenged me:","sidebar":"k8sEcosystemMythsSidebar"},"k8s-platform-myths/amazon-eks-myths/EKS-Control-Plane-Performance-Can\u2019t-Be-Tuned":{"id":"k8s-platform-myths/amazon-eks-myths/EKS-Control-Plane-Performance-Can\u2019t-Be-Tuned","title":"Myth: EKS Control Plane Performance Can\u2019t Be Tuned","description":"During interviews and discussions with cloud engineers, this statement comes up frequently. Many teams running EKS clusters experience throttling on the Kubernetes API server or delays in pod creation and assume there is nothing they can do \u2014 after all, AWS fully manages the control plane.","sidebar":"k8sPlatformMythsSidebar"},"k8s-platform-myths/google-gke-myths/GKE_Zonal_Clusters_Are_Cheaper_Than_Regional_Clusters":{"id":"k8s-platform-myths/google-gke-myths/GKE_Zonal_Clusters_Are_Cheaper_Than_Regional_Clusters","title":"Myth: GKE Zonal Clusters Are Cheaper Than Regional Clusters","description":"Early in my GKE journey, I assumed zonal clusters were the obvious cost saver. \u201cFewer zones, lower cost,\u201d I thought. It seemed intuitive, and I even recommended zonal clusters to teams looking to save a few dollars.","sidebar":"k8sPlatformMythsSidebar"},"kubernetes-myths":{"id":"kubernetes-myths","title":"Kubernetes Myths & Reality - Production, Architecture & Interview Guide","description":"A comprehensive guide to debunking Kubernetes myths, covering architecture, networking, security, EKS, GKE, AKS, and common interview traps. Perfect for CKA/CKS prep and production cluster deep dives."},"the-kubernetes-mythologist":{"id":"the-kubernetes-mythologist","title":"The Kubernetes Mythologist","description":"Meet Rajesh Deshpande \u2014 decoding Kubernetes myths with experiments, source code, and production insights."}}}}')}}]);